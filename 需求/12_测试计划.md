# 通用控制器需求文档 - 测试计划

> 版本: v3.17.6

## 1. 单元测试

| 模块 | 测试内容 |
|------|----------|
| AdaptiveEKF | apply_drift_correction、_get_theta_for_transform (v3.17) |
| WeightedConsistency | data_valid 综合判断、temporal_valid 修复 (v3.17) |
| RobustTransformer | 漂移校正逻辑 |
| BasicSafetyMonitor | limited_cmd 完整复制 (v3.17)、reset 方法 |
| PurePursuit | shutdown 方法 |
| MPCController | shutdown 方法、fallback 求解 (v3.17)、set_horizon 重新初始化 (v3.17.3)、theta_ref 初始化 (v3.17.4)、配置传递 (v3.17.6) |
| StateMachine | data_valid 和 safety_failed 影响状态转换、恢复计数器重置 (v3.17.3) |
| ControllerManager | reset、shutdown、立即状态转换 (v3.17)、诊断发布 (v3.17)、IMU 超时更新 (v3.17.3)、initialize_components (v3.17.4)、延迟绑定 (v3.17.5)、_last_published_diagnostics (v3.17.6) |
| ControlOutput | copy() 方法 (v3.17) |
| TimeoutMonitor | update_imu 调用验证 (v3.17.3) |
| DiagnosticsV2 | to_ros_msg() 方法、字段完整性 (v3.17.5) |
| Trajectory | get_velocities() 统一接口、has_valid_soft_velocities() (v3.17.5) |
| DEFAULT_CONFIG | 默认配置常量完整性 (v3.17.5) |
| get_config_value | 配置获取方法 (v3.17.5) |

## 2. 集成测试

| 场景 | 预期行为 |
|------|----------|
| TF2 恢复校正 | 正确计算漂移，调用 apply_drift_correction |
| 安全检查失败 | 立即使用 limited_cmd，立即更新状态机 (v3.17) |
| data_valid=False | 阻止从 SOFT_DISABLED 恢复到 NORMAL |
| 系统重置 | 所有组件状态正确重置 |
| 资源清理 | shutdown 后所有订阅器正确取消 |
| MPC 未配置 | 系统使用 backup_tracker |
| EKF θ 协方差过大 | 使用 odom orientation 作为备选 (v3.17) |
| 诊断发布 | 正确发布所有诊断字段 (v3.17) |
| IMU 超时 | 正确检测 IMU 超时并降级到纯 odom 估计 (v3.17.3) |
| MPC horizon 降级 | MPC_DEGRADED 状态下 horizon 正确降低并生效 (v3.17.3) |
| 组件初始化 | initialize_components 正确注入所有组件 (v3.17.4) |
| 组件延迟绑定 | coord_transformer 无论注入顺序都能获得 state_estimator (v3.17.5) |
| DiagnosticsV2 发布 | 诊断消息正确构建并发布 (v3.17.5) |
| 诊断数据转换 | _publish_diagnostics 使用 to_ros_msg() 转换，_last_published_diagnostics 正确设置 (v3.17.6) |

## 3. v3.17 新增测试用例

### 3.1 ControlOutput.copy() 测试

```python
def test_control_output_copy():
    """测试 ControlOutput 深拷贝"""
    original = ControlOutput(
        vx=1.0, vy=0.5, vz=0.0, omega=0.1,
        frame_id="world", success=True,
        solve_time_ms=5.0,
        health_metrics={'kkt_residual': 0.001, 'condition_number': 100}
    )
    
    copied = original.copy()
    
    # 修改原始对象
    original.vx = 2.0
    original.health_metrics['kkt_residual'] = 0.1
    
    # 验证拷贝不受影响
    assert copied.vx == 1.0
    assert copied.health_metrics['kkt_residual'] == 0.001
```

### 3.2 temporal_valid 修复测试

```python
def test_temporal_valid_requires_two_samples():
    """测试时序有效性需要至少 2 个样本"""
    analyzer = WeightedConsistencyAnalyzer(config)
    
    # 第一次调用
    traj1 = create_test_trajectory(soft_enabled=True)
    result1 = analyzer.compute(traj1)
    assert result1.data_valid == False  # 只有 1 个样本
    
    # 第二次调用
    traj2 = create_test_trajectory(soft_enabled=True)
    result2 = analyzer.compute(traj2)
    assert result2.data_valid == True  # 现在有 2 个样本
```

### 3.3 立即状态转换测试

```python
def test_immediate_state_transition_on_safety_failure():
    """测试安全检查失败时立即状态转换"""
    manager = ControllerManager(config)
    # ... 初始化组件
    
    manager._last_state = ControllerState.NORMAL
    
    # 发送超限命令
    cmd = manager.update(odom, trajectory_with_high_speed)
    
    # 验证状态立即转换
    assert manager.get_state() == ControllerState.MPC_DEGRADED
    # 验证输出已被限制
    assert cmd.v_horizontal <= config['constraints']['v_max']
```

### 3.4 v3.17.3 IMU 超时检测测试

```python
def test_imu_timeout_detection():
    """测试 IMU 超时检测正常工作"""
    # 配置启用 IMU 超时检测 (默认禁用)
    config['watchdog']['imu_timeout_ms'] = 100
    manager = ControllerManager(config)
    # ... 初始化组件
    
    # 发送带 IMU 的更新
    imu = create_test_imu()
    manager.update(odom, trajectory, imu)
    
    # 等待超过 IMU 超时时间
    time.sleep(0.15)  # imu_timeout_ms = 100 (显式启用)
    
    # 不发送 IMU 的更新
    manager.update(odom, trajectory, None)
    
    # 验证 IMU 超时被检测到
    timeout_status = manager.get_timeout_status()
    assert timeout_status.imu_timeout == True
    
    # 验证 EKF 的 imu_available 被设置为 False
    state_output = manager.state_estimator.get_state()
    assert state_output.imu_available == False
```

### 3.5 v3.17.3 状态机恢复计数器重置测试

```python
def test_state_machine_counter_reset_on_transition():
    """测试状态转换时恢复计数器正确重置"""
    sm = StateMachine(config)
    sm.state = ControllerState.SOFT_DISABLED
    sm.alpha_recovery_count = 3  # 模拟部分恢复
    
    # 触发 safety_failed 转换到 MPC_DEGRADED
    diagnostics = {
        'alpha': 0.5,
        'mpc_health': None,
        'mpc_success': True,
        'odom_timeout': False,
        'traj_timeout_exceeded': False,
        'has_valid_data': True,
        'tf2_critical': False,
        'data_valid': True,
        'safety_failed': True,
    }
    
    new_state = sm.update(diagnostics)
    
    # 验证状态转换
    assert new_state == ControllerState.MPC_DEGRADED
    # 验证计数器被重置
    assert sm.alpha_recovery_count == 0
    assert sm.mpc_recovery_count == 0
```

### 3.6 v3.17.3 MPC horizon 动态调整测试

```python
def test_mpc_horizon_dynamic_adjustment():
    """测试 MPC horizon 动态调整生效"""
    mpc = MPCController(config['mpc'], platform_config)
    
    original_horizon = mpc.horizon
    assert original_horizon == 20
    
    # 调整 horizon
    mpc.set_horizon(10)
    
    # 验证 horizon 已更新
    assert mpc.horizon == 10
    
    # 验证求解器已重新初始化（如果 ACADOS 可用）
    # 注意: 实际测试需要检查求解器内部状态
```

### 3.7 v3.17.4 组件初始化测试

```python
def test_controller_manager_initialize_components():
    """测试 ControllerManager 组件注入"""
    manager = ControllerManager(config)
    
    # 创建模拟组件
    estimator = AdaptiveEKFEstimator(config['ekf'])
    mpc = MPCController(config['mpc'], platform_config)
    backup = PurePursuitController(config['backup'], platform_config)
    consistency = WeightedConsistencyAnalyzer(config['consistency'])
    safety = BasicSafetyMonitor(config, platform_config)
    
    # 注入组件
    manager.initialize_components(
        state_estimator=estimator,
        mpc_tracker=mpc,
        backup_tracker=backup,
        consistency_checker=consistency,
        safety_monitor=safety
    )
    
    # 验证组件已注入
    assert manager.state_estimator is estimator
    assert manager.mpc_tracker is mpc
    assert manager.backup_tracker is backup
    assert manager.consistency_checker is consistency
    assert manager.safety_monitor is safety
    assert manager.state_machine is not None
```

### 3.9 v3.17.5 组件延迟绑定测试

```python
def test_component_delayed_binding():
    """测试组件延迟绑定，无论注入顺序都能正确绑定"""
    manager = ControllerManager(config)
    
    # 先注入 coord_transformer，再注入 state_estimator
    transformer = RobustCoordinateTransformer(config['transform'])
    estimator = AdaptiveEKFEstimator(config['ekf'])
    
    # 分两次注入，顺序相反
    manager.initialize_components(coord_transformer=transformer)
    manager.initialize_components(state_estimator=estimator)
    
    # 验证 transformer 获得了 estimator 引用
    assert manager.coord_transformer.state_estimator is estimator
```

### 3.11 v3.17.5 Trajectory 统一速度接口测试

```python
def test_trajectory_get_velocities_unified():
    """测试 Trajectory.get_velocities() 统一接口"""
    # 测试 1: soft_enabled=True 且有 velocities
    traj1 = Trajectory(
        header=Header(),
        points=[Point3D(0, 0, 0), Point3D(1, 0, 0)],
        velocities=np.array([[1.0, 0.0, 0.0, 0.0]]),
        dt_sec=0.1,
        confidence=0.9,
        soft_enabled=True
    )
    vel1 = traj1.get_velocities()
    assert np.allclose(vel1[0], [1.0, 0.0, 0.0, 0.0])
    assert traj1.has_valid_soft_velocities() == True
    
    # 测试 2: soft_enabled=False，应返回 hard velocities
    traj2 = Trajectory(
        header=Header(),
        points=[Point3D(0, 0, 0), Point3D(1, 0, 0)],
        velocities=np.array([[1.0, 0.0, 0.0, 0.0]]),
        dt_sec=0.1,
        confidence=0.9,
        soft_enabled=False
    )
    vel2 = traj2.get_velocities()
    # 应该是从 hard 轨迹点计算的速度
    assert vel2.shape[1] == 4
    assert traj2.has_valid_soft_velocities() == False
    
    # 测试 3: velocities=None，应返回 hard velocities
    traj3 = Trajectory(
        header=Header(),
        points=[Point3D(0, 0, 0), Point3D(1, 0, 0)],
        velocities=None,
        dt_sec=0.1,
        confidence=0.9,
        soft_enabled=True
    )
    vel3 = traj3.get_velocities()
    assert vel3 is not None
    assert vel3.shape[1] == 4
```

### 3.12 v3.17.5 配置默认值测试

```python
def test_default_config_completeness():
    """测试默认配置完整性"""
    from config import DEFAULT_CONFIG, get_config_value
    
    # 测试所有必需的配置路径
    required_paths = [
        'system.ctrl_freq',
        'mpc.horizon',
        'watchdog.odom_timeout_ms',
        'consistency.alpha_min',
        'safety.v_stop_thresh',
        'transform.target_frame',
        'backup.lookahead_dist',
        'constraints.v_max',
        'ekf.adaptive.base_slip_thresh',
    ]
    
    for path in required_paths:
        value = get_config_value({}, path)
        assert value is not None, f"Missing default for {path}"


def test_get_config_value():
    """测试配置获取方法"""
    config = {
        'mpc': {
            'horizon': 30,  # 覆盖默认值
        }
    }
    
    # 测试覆盖值
    assert get_config_value(config, 'mpc.horizon') == 30
    
    # 测试默认值回退
    assert get_config_value(config, 'mpc.dt') == 0.02
    
    # 测试不存在的路径
    assert get_config_value(config, 'nonexistent.path', 'default') == 'default'
```

### 3.13 v3.17.6 诊断发布转换测试

```python
def test_diagnostics_publish_conversion():
    """测试诊断发布使用 to_ros_msg() 转换"""
    manager = ControllerManager(config)
    manager.initialize_components(
        state_estimator=AdaptiveEKFEstimator(config['ekf']),
        backup_tracker=PurePursuitController(config['backup'], platform_config)
    )
    
    # 执行一次更新
    odom = create_test_odom()
    trajectory = create_test_trajectory()
    manager.update(odom, trajectory)
    
    # 验证 _last_published_diagnostics 已设置
    assert manager._last_published_diagnostics is not None
    assert isinstance(manager._last_published_diagnostics, dict)
    
    # 验证关键字段存在
    assert 'state' in manager._last_published_diagnostics
    assert 'mpc_success' in manager._last_published_diagnostics
    assert 'timeout' in manager._last_published_diagnostics
```


---

## 4. 版本历史

| 版本 | 日期 | 变更内容 |
|------|------|----------|
| v1.0 | - | 初始版本 |
| v2.0 | 2024-12 | 统一状态空间、ACADOS求解器、EKF状态估计、多维一致性、Pure Pursuit热备、TF2坐标变换 |
| v3.0 | 2024-12 | 插件化架构、自适应EKF、加权几何平均融合、MPC预测性降级、平滑过渡控制器、增强坐标变换、无人机姿态内环、完善诊断信息 |
| v3.1-v3.12 | 2024-12 | 多次 Bug 修复迭代 |
| v3.13 | 2024-12-21 | Bug修复：动态frame_id、启动宽限期、坐标变换目标帧、角度归一化、IMU/Odom更新顺序等 |
| v3.14 | 2024-12-21 | Bug修复：TimeoutMonitor age_ms、v_min默认值、EKF首次打滑检测、一致性空数据处理、MANUAL模式、全向车约束、TF2恢复校正、SafetyMonitor集成 |
| v3.15 | 2024-12-21 | Bug修复：TF2恢复校正实现、SafetyMonitor完整检查、data_valid综合判断、状态机考虑data_valid和safety_failed、mpc_success默认False、PurePursuit shutdown方法、ControllerManager reset/shutdown方法 |
| v3.16 | 2024-12-21 | Bug修复：TF2漂移校正逻辑重新设计、安全检查失败时立即使用限制后的命令、补充MPC控制器关键实现、完善配置参数默认值说明、添加data_valid语义说明、添加低速阈值说明 |
| v3.17 | 2024-12-21 | **Bug修复**：(1) SafetyMonitor limited_cmd 完整复制 health_metrics；(2) temporal_valid 需要至少 2 个历史数据；(3) MPC 控制器完善 ACADOS 集成框架和 fallback 求解；(4) 添加诊断消息发布功能；(5) 安全检查失败后立即更新状态机；(6) EKF 支持 odom orientation 作为航向备选；(7) ControlOutput 添加 copy() 方法 |
| v3.17.3 | 2024-12-21 | **Bug修复**：(1) ControllerManager 添加 `timeout_monitor.update_imu()` 调用，修复 IMU 超时检测不工作；(2) StateMachine 从 SOFT_DISABLED 转换时重置所有恢复计数器；(3) MPCController.set_horizon() 添加求解器重新初始化逻辑；(4) ControllerManager 添加 MPC horizon 动态调整逻辑 |
| v3.17.4 | 2024-12-21 | **Bug修复**：(1) 添加依赖导入声明（ROS 消息类型、TF2、标准库）；(2) ControllerManager 添加 `initialize_components()` 组件注入方法；(3) MPCController._solve_with_acados() 在循环外初始化 `theta_ref`，修复潜在的未定义变量问题 |
| v3.17.5 | 2024-12-21 | **Bug修复**：(1) 添加 DiagnosticsV2 dataclass 定义，包含完整字段和 to_ros_msg() 方法；(2) ControllerManager.initialize_components() 改为延迟绑定，确保 coord_transformer 无论注入顺序都能获得 state_estimator；(3) 添加 ACADOS/CasADi 条件导入声明；(4) 实现 _publish_diagnostics() 的实际诊断消息发布；(5) Trajectory 添加 get_velocities() 统一接口和 has_valid_soft_velocities() 方法；(6) 配置参数添加 DEFAULT_CONFIG 常量和 get_config_value() 方法，完善所有参数说明 |
| v3.17.6 | 2024-12-21 | **Bug修复**：(1) _publish_diagnostics() 修复 DiagnosticsV2 dataclass 不能直接发布的问题，改用 to_ros_msg() 转换；(2) 添加 _last_published_diagnostics 字段；(3) 修正测试用例 test_mpc_horizon_dynamic_adjustment 的配置传递错误 |

---

## 5. 术语表

| 术语 | 定义 |
|------|------|
| Hard Head | 网络输出的 XYZ 轨迹，必选 |
| Soft Head | 网络输出的速度建议，可选 |
| α_soft | Soft 建议的融合权重 |
| ACADOS | 高性能嵌入式 MPC 求解器 |
| EKF | 扩展卡尔曼滤波器 |
| Pure Pursuit | 几何路径跟踪算法 |
| 热备 | 备用系统始终运行，可即时切换 |
| 统一状态空间 | 所有平台使用相同维度的状态向量 |
| 加权几何平均 | 多维度融合的数学方法 |
| 预测性降级 | 在故障发生前主动降级 |
| Joseph 形式 | Kalman 滤波协方差更新的数值稳定形式 |
| 世界坐标系 | 固定的全局参考坐标系 |
| 机体坐标系 | 随机器人移动的局部坐标系 |
| 速度-航向耦合 | 非全向车辆速度方向与航向一致的约束 |
| HeadingMode | 全向车/无人机的航向控制模式 |
| TimeoutMonitor | 超时监控组件 |
| 启动宽限期 | 系统启动时不判定超时的时间窗口 |
| data_valid | 一致性计算数据有效性标志 |
| safety_failed | 安全检查失败标志 |
| limited_cmd | 安全监控器返回的限制后命令 |
| 漂移 | TF2 变换与 odom 积分之间的误差 |
| fallback 求解 | MPC 不可用时的简化控制算法 (v3.17) |
| 航向备选 | EKF θ 协方差过大时使用 odom orientation (v3.17) |
