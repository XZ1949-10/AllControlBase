# 通用控制器需求文档 - 状态估计器

> 版本: v3.17

## 1. 超时监控器 (TimeoutMonitor)

```python
class TimeoutMonitor:
    """
    超时监控器
    
    启动宽限期说明:
    - 系统启动时，传感器数据可能尚未到达
    - 宽限期内不判定超时，避免误触发停车
    - 宽限期从收到第一个传感器数据开始计时
    """
    
    def __init__(self, config: Dict[str, Any]):
        watchdog_config = config.get('watchdog', {})
        self.odom_timeout_ms = watchdog_config.get('odom_timeout_ms', 500)
        self.traj_timeout_ms = watchdog_config.get('traj_timeout_ms', 1000)
        self.traj_grace_ms = watchdog_config.get('traj_grace_ms', 500)
        self.imu_timeout_ms = watchdog_config.get('imu_timeout_ms', -1)  # 默认禁用
        self.startup_grace_ms = watchdog_config.get('startup_grace_ms', 5000)
        
        self._startup_time: Optional[rospy.Time] = None
        self._last_odom_time: Optional[rospy.Time] = None
        self._last_traj_time: Optional[rospy.Time] = None
        self._last_imu_time: Optional[rospy.Time] = None
        self._traj_timeout_start: Optional[rospy.Time] = None
    
    def update_odom(self, stamp: rospy.Time) -> None:
        self._last_odom_time = stamp
        if self._startup_time is None:
            self._startup_time = rospy.Time.now()
    
    def update_trajectory(self, stamp: rospy.Time) -> None:
        self._last_traj_time = stamp
        self._traj_timeout_start = None
        if self._startup_time is None:
            self._startup_time = rospy.Time.now()
    
    def update_imu(self, stamp: rospy.Time) -> None:
        self._last_imu_time = stamp
        if self._startup_time is None:
            self._startup_time = rospy.Time.now()
    
    def check(self, current_time: rospy.Time) -> TimeoutStatus:
        """检查所有超时状态"""
        # 启动宽限期检查
        in_startup_grace = False
        if self._startup_time is None:
            in_startup_grace = True
        else:
            startup_elapsed_ms = (current_time - self._startup_time).to_sec() * 1000
            in_startup_grace = startup_elapsed_ms < self.startup_grace_ms
        
        if in_startup_grace:
            return TimeoutStatus(
                odom_timeout=False, traj_timeout=False, traj_grace_exceeded=False,
                imu_timeout=False, last_odom_age_ms=0.0, last_traj_age_ms=0.0,
                last_imu_age_ms=0.0, in_startup_grace=True
            )
        
        # 计算各传感器超时状态
        odom_age_ms = self._compute_age_ms(self._last_odom_time, current_time)
        traj_age_ms = self._compute_age_ms(self._last_traj_time, current_time)
        imu_age_ms = self._compute_age_ms(self._last_imu_time, current_time)
        
        odom_timeout = odom_age_ms > self.odom_timeout_ms
        imu_timeout = imu_age_ms > self.imu_timeout_ms
        
        traj_timeout = traj_age_ms > self.traj_timeout_ms
        traj_grace_exceeded = False
        
        if traj_timeout:
            if self._traj_timeout_start is None:
                self._traj_timeout_start = current_time
            grace_elapsed_ms = (current_time - self._traj_timeout_start).to_sec() * 1000
            traj_grace_exceeded = grace_elapsed_ms > self.traj_grace_ms
        else:
            self._traj_timeout_start = None
        
        return TimeoutStatus(
            odom_timeout=odom_timeout,
            traj_timeout=traj_timeout,
            traj_grace_exceeded=traj_grace_exceeded,
            imu_timeout=imu_timeout,
            last_odom_age_ms=odom_age_ms,
            last_traj_age_ms=traj_age_ms,
            last_imu_age_ms=imu_age_ms,
            in_startup_grace=False
        )
    
    def _compute_age_ms(self, last_time: Optional[rospy.Time], 
                        current_time: rospy.Time) -> float:
        """计算时间戳年龄（毫秒）"""
        if last_time is None:
            return float('inf')
        return (current_time - last_time).to_sec() * 1000
    
    def reset(self) -> None:
        """重置所有时间戳"""
        self._last_odom_time = None
        self._last_traj_time = None
        self._last_imu_time = None
        self._traj_timeout_start = None
        self._startup_time = None
```


## 2. 统一状态空间设计

```python
"""
统一状态空间 (8维): [px, py, pz, vx, vy, vz, θ, ω]
- px, py, pz: 世界坐标系下的位置
- vx, vy, vz: 世界坐标系下的速度
- θ: 世界坐标系下的航向角 (yaw)
- ω: 世界坐标系下的角速度 (yaw rate)

EKF 内部状态 (11维): [px, py, pz, vx, vy, vz, θ, ω, bias_ax, bias_ay, bias_az]
- bias_ax, bias_ay, bias_az: IMU 加速度计偏置 (机体坐标系)

过程噪声模型说明:
- 采用离散时间白噪声模型
- Q 矩阵按 dt 线性缩放: P = F @ P @ F.T + Q * dt
"""

PLATFORM_CONFIG = {
    "ackermann": {
        "type": PlatformType.ACKERMANN,
        "active_dims": [0, 1, 3, 6],
        "control_dims": [3, 7],
        "constraints": {"pz": 0, "vy": 0, "vz": 0, "curvature": True},
        "velocity_heading_coupled": True,
        "output_type": "differential",
        "output_frame": "base_link"
    },
    "differential": {
        "type": PlatformType.DIFFERENTIAL,
        "active_dims": [0, 1, 3, 6, 7],
        "control_dims": [3, 7],
        "constraints": {"pz": 0, "vy": 0, "vz": 0, "curvature": False},
        "velocity_heading_coupled": True,
        "output_type": "differential",
        "output_frame": "base_link"
    },
    "omni": {
        "type": PlatformType.OMNI,
        "active_dims": [0, 1, 3, 4, 6, 7],
        "control_dims": [3, 4, 7],
        "constraints": {"pz": 0, "vz": 0},
        "velocity_heading_coupled": False,
        "output_type": "omni",
        "output_frame": "world"
    },
    "quadrotor": {
        "type": PlatformType.QUADROTOR,
        "active_dims": [0, 1, 2, 3, 4, 5, 6, 7],
        "control_dims": [3, 4, 5, 7],
        "constraints": {},
        "attitude_interface": True,
        "velocity_heading_coupled": False,
        "output_type": "3d",
        "output_frame": "world"
    }
}
```


## 3. 自适应 EKF 状态估计器 (v3.17 增强)

```python
class AdaptiveEKFEstimator(IStateEstimator):
    """
    自适应 EKF 状态估计器
    
    v3.17 增强:
    - 支持使用 odom orientation 作为航向备选
    - 当 EKF θ 协方差过大时，可选择信任 odom 的航向
    """
    
    def __init__(self, config: Dict[str, Any]):
        # 状态向量
        self.x = np.zeros(11)
        self.P = np.eye(11) * 0.1
        
        # 平台类型
        platform_name = config.get('platform', 'differential')
        self.platform_config = PLATFORM_CONFIG.get(platform_name, PLATFORM_CONFIG['differential'])
        self.velocity_heading_coupled = self.platform_config.get('velocity_heading_coupled', True)
        
        # 自适应参数
        self.base_slip_thresh = config['adaptive']['base_slip_thresh']
        self.slip_velocity_factor = config['adaptive']['slip_velocity_factor']
        self.slip_covariance_scale = config['adaptive']['slip_covariance_scale']
        self.stationary_covariance_scale = config['adaptive']['stationary_covariance_scale']
        self.stationary_thresh = config['adaptive'].get('stationary_thresh', 0.05)
        
        # v3.17: 航向备选参数
        self.use_odom_orientation_fallback = config.get('use_odom_orientation_fallback', True)
        self.theta_covariance_fallback_thresh = config.get('theta_covariance_fallback_thresh', 0.5)
        self._last_odom_orientation: Optional[Quaternion] = None
        
        # 测量噪声
        self.R_odom_base = np.diag([
            config['measurement_noise']['odom_position']] * 3 +
            [config['measurement_noise']['odom_velocity']] * 3
        )
        self.R_odom_current = self.R_odom_base.copy()
        
        self.R_imu = np.diag([
            config['measurement_noise']['imu_accel']] * 3 +
            [config['measurement_noise']['imu_gyro']]
        )
        
        # 过程噪声
        self.Q = np.diag([
            config['process_noise']['position']] * 3 +
            [config['process_noise']['velocity']] * 3 +
            [config['process_noise']['orientation'],
             config['process_noise']['angular_velocity']] +
            [config['process_noise']['imu_bias']] * 3
        )
        
        # 异常检测阈值
        self.drift_thresh = config['anomaly_detection']['drift_thresh']
        self.jump_thresh = config['anomaly_detection']['jump_thresh']
        self.min_eigenvalue = config['covariance'].get('min_eigenvalue', 1e-6)
        
        # IMU 运动加速度补偿
        self.imu_motion_compensation = config.get('imu_motion_compensation', False)
        
        # 状态变量
        self.slip_detected = False
        self.slip_probability = 0.0
        self.last_innovation_norm = 0.0
        self.last_position = np.zeros(3)
        self.position_jump = 0.0
        self.gyro_z = 0.0
        self._imu_drift_detected = False
        
        # 打滑概率计算
        self.slip_history = deque(maxlen=20)
        
        # 保存世界坐标系下的加速度向量
        self.last_world_velocity = np.zeros(2)
        self.current_world_velocity = np.zeros(2)
        self.last_odom_time: Optional[rospy.Time] = None
        self.world_accel_vec = np.zeros(2)
        
        # world_accel_vec 初始化标志
        self._world_accel_initialized = False
        
        self.last_imu_time: Optional[rospy.Time] = None
        self._imu_available = True
    
    def set_imu_available(self, available: bool) -> None:
        self._imu_available = available
```

### 3.1 核心方法

```python
    def _get_theta_for_transform(self) -> float:
        """
        v3.17: 获取用于坐标变换的航向角
        当 EKF θ 协方差过大时，使用 odom orientation 作为备选
        """
        theta_var = self.P[6, 6]
        
        if (self.use_odom_orientation_fallback and 
            theta_var > self.theta_covariance_fallback_thresh and
            self._last_odom_orientation is not None):
            q = self._last_odom_orientation
            _, _, yaw = tft.euler_from_quaternion([q.x, q.y, q.z, q.w])
            rospy.logwarn_throttle(5.0, 
                f"EKF theta variance {theta_var:.3f} > thresh, using odom orientation")
            return yaw
        
        return self.x[6]
    
    def apply_drift_correction(self, dx: float, dy: float, dtheta: float) -> None:
        """应用外部漂移校正"""
        self.x[0] += dx
        self.x[1] += dy
        self.x[6] += dtheta
        self.x[6] = np.arctan2(np.sin(self.x[6]), np.cos(self.x[6]))
        
        if self.velocity_heading_coupled:
            v_body = np.sqrt(self.x[3]**2 + self.x[4]**2)
            new_theta = self.x[6]
            self.x[3] = v_body * np.cos(new_theta)
            self.x[4] = v_body * np.sin(new_theta)
        
        # 增加协方差不确定性
        self.P[0, 0] += abs(dx) * 0.1
        self.P[1, 1] += abs(dy) * 0.1
        self.P[6, 6] += abs(dtheta) * 0.1
    
    def predict(self, dt: float) -> None:
        """运动学预测"""
        if dt <= 0:
            return
        
        # 状态预测
        self.x[0] += self.x[3] * dt
        self.x[1] += self.x[4] * dt
        self.x[2] += self.x[5] * dt
        self.x[6] += self.x[7] * dt
        self.x[6] = np.arctan2(np.sin(self.x[6]), np.cos(self.x[6]))
        
        # 速度-航向耦合
        if self.velocity_heading_coupled and abs(self.x[7]) > 1e-6:
            v_body = np.sqrt(self.x[3]**2 + self.x[4]**2)
            self.x[3] = v_body * np.cos(self.x[6])
            self.x[4] = v_body * np.sin(self.x[6])
        
        # 协方差预测
        F = self._compute_jacobian(dt, self.x[6], self.x[7])
        self.P = F @ self.P @ F.T + self.Q * dt
        self._ensure_positive_definite()
    
    def update_odom(self, odom: Odometry) -> None:
        """Odom 更新"""
        current_time = rospy.Time.now()
        
        # v3.17: 保存 odom orientation 用于备选
        self._last_odom_orientation = odom.pose.pose.orientation
        
        new_position = np.array([
            odom.pose.pose.position.x,
            odom.pose.pose.position.y,
            odom.pose.pose.position.z
        ])
        self.position_jump = np.linalg.norm(new_position - self.last_position)
        self.last_position = new_position
        
        vx_body = odom.twist.twist.linear.x
        vy_body = odom.twist.twist.linear.y
        vz_body = odom.twist.twist.linear.z
        v_body = np.sqrt(vx_body**2 + vy_body**2)
        
        # v3.17: 使用可能的备选航向
        theta = self._get_theta_for_transform()
        cos_theta = np.cos(theta)
        sin_theta = np.sin(theta)
        
        vx_world = vx_body * cos_theta - vy_body * sin_theta
        vy_world = vx_body * sin_theta + vy_body * cos_theta
        vz_world = vz_body
        
        self.last_world_velocity = self.current_world_velocity.copy()
        self.current_world_velocity = np.array([vx_world, vy_world])
        
        if self.last_odom_time is not None:
            dt = (current_time - self.last_odom_time).to_sec()
            if dt > 0:
                self.world_accel_vec = (self.current_world_velocity - self.last_world_velocity) / dt
                self._world_accel_initialized = True
            else:
                self.world_accel_vec = np.zeros(2)
        else:
            self.world_accel_vec = np.zeros(2)
        
        self.last_odom_time = current_time
        self._update_odom_covariance(v_body)
        
        z = np.array([
            odom.pose.pose.position.x,
            odom.pose.pose.position.y,
            odom.pose.pose.position.z,
            vx_world,
            vy_world,
            vz_world,
        ])
        
        H = np.zeros((6, 11))
        H[0:3, 0:3] = np.eye(3)
        H[3:6, 3:6] = np.eye(3)
        
        self._kalman_update(z, H, self.R_odom_current)
    
    def update_imu(self, imu: Imu) -> None:
        """IMU 观测更新"""
        if not self._imu_available:
            return
        
        self.gyro_z = imu.angular_velocity.z
        theta = self.x[6]
        cos_theta = np.cos(theta)
        sin_theta = np.sin(theta)
        
        ax_body = imu.linear_acceleration.x - self.x[8]
        ay_body = imu.linear_acceleration.y - self.x[9]
        
        ax_world = ax_body * cos_theta - ay_body * sin_theta
        ay_world = ax_body * sin_theta + ay_body * cos_theta
        
        # 打滑检测 (首次跳过，等待 world_accel_vec 初始化)
        if self._world_accel_initialized:
            imu_accel_world = np.array([ax_world, ay_world])
            accel_diff = np.linalg.norm(imu_accel_world - self.world_accel_vec)
            self.slip_probability = self._compute_slip_probability(accel_diff)
            self.slip_detected = self.slip_probability > 0.5
        else:
            self.slip_probability = 0.0
            self.slip_detected = False
        
        self.last_imu_time = rospy.Time.now()
        
        z = np.array([
            imu.linear_acceleration.x,
            imu.linear_acceleration.y,
            imu.linear_acceleration.z,
            imu.angular_velocity.z,
        ])
        
        H = np.zeros((4, 11))
        H[0, 8] = 1.0
        H[1, 9] = 1.0
        H[2, 10] = 1.0
        H[3, 7] = 1.0
        
        if self.imu_motion_compensation and self._world_accel_initialized:
            ax_motion_body = self.world_accel_vec[0] * cos_theta + self.world_accel_vec[1] * sin_theta
            ay_motion_body = -self.world_accel_vec[0] * sin_theta + self.world_accel_vec[1] * cos_theta
            z_expected = np.array([
                self.x[8] + ax_motion_body,
                self.x[9] + ay_motion_body,
                self.x[10] + 9.81,
                self.x[7],
            ])
        else:
            z_expected = np.array([self.x[8], self.x[9], self.x[10] + 9.81, self.x[7]])
        
        self._kalman_update_with_expected(z, z_expected, H, self.R_imu)
    
    def _kalman_update(self, z: np.ndarray, H: np.ndarray, R: np.ndarray):
        y = z - H @ self.x
        self._apply_kalman_gain(y, H, R)
    
    def _kalman_update_with_expected(self, z: np.ndarray, z_expected: np.ndarray,
                                     H: np.ndarray, R: np.ndarray):
        y = z - z_expected
        self._apply_kalman_gain(y, H, R)
    
    def _apply_kalman_gain(self, y: np.ndarray, H: np.ndarray, R: np.ndarray):
        S = H @ self.P @ H.T + R
        try:
            L = np.linalg.cholesky(S)
            K = self.P @ H.T @ np.linalg.solve(L.T, np.linalg.solve(L, np.eye(len(S))))
        except np.linalg.LinAlgError:
            K = self.P @ H.T @ np.linalg.pinv(S)
        
        self.x = self.x + K @ y
        I_KH = np.eye(11) - K @ H
        self.P = I_KH @ self.P @ I_KH.T + K @ R @ K.T
        self._ensure_positive_definite()
        self.last_innovation_norm = np.linalg.norm(y)
        
        # 归一化航向角
        self.x[6] = np.arctan2(np.sin(self.x[6]), np.cos(self.x[6]))
    
    def _compute_jacobian(self, dt: float, theta: float, omega: float) -> np.ndarray:
        """计算状态转移 Jacobian"""
        F = np.eye(11)
        F[0, 3] = dt
        F[1, 4] = dt
        F[2, 5] = dt
        F[6, 7] = dt
        
        if self.velocity_heading_coupled:
            v_body = np.sqrt(self.x[3]**2 + self.x[4]**2)
            if v_body > 1e-6 and abs(omega) > 1e-6:
                new_theta = theta + omega * dt
                F[3, 6] = -v_body * np.sin(new_theta)
                F[4, 6] = v_body * np.cos(new_theta)
                F[3, 7] = -v_body * np.sin(new_theta) * dt
                F[4, 7] = v_body * np.cos(new_theta) * dt
        
        return F
    
    def _ensure_positive_definite(self):
        """确保协方差矩阵正定"""
        self.P = (self.P + self.P.T) / 2
        try:
            eigenvalues, eigenvectors = np.linalg.eigh(self.P)
            if np.any(eigenvalues < self.min_eigenvalue):
                eigenvalues = np.maximum(eigenvalues, self.min_eigenvalue)
                self.P = eigenvectors @ np.diag(eigenvalues) @ eigenvectors.T
                rospy.logwarn_throttle(5.0, "EKF: Fixed non-positive-definite covariance")
        except np.linalg.LinAlgError:
            rospy.logwarn("EKF: Covariance decomposition failed, resetting")
            self.P = np.eye(11) * 0.1
    
    def _get_adaptive_slip_threshold(self) -> float:
        current_velocity = np.linalg.norm(self.x[3:6])
        return self.base_slip_thresh + self.slip_velocity_factor * current_velocity
    
    def _is_stationary(self) -> bool:
        return np.linalg.norm(self.x[3:6]) < self.stationary_thresh
    
    def _update_odom_covariance(self, v_body: float):
        """更新 odom 测量噪声协方差"""
        if self.slip_detected:
            self.R_odom_current = self.R_odom_base * self.slip_covariance_scale
        elif self._is_stationary():
            self.R_odom_current = self.R_odom_base * self.stationary_covariance_scale
        else:
            self.R_odom_current = self.R_odom_base.copy()
        
        theta_var = self.P[6, 6]
        if theta_var > 0 and v_body > 0.1:
            velocity_transform_var = (v_body ** 2) * theta_var
            self.R_odom_current[3, 3] += velocity_transform_var
            self.R_odom_current[4, 4] += velocity_transform_var
    
    def _compute_slip_probability(self, accel_diff: float) -> float:
        slip_thresh = self._get_adaptive_slip_threshold()
        k = 5.0 / slip_thresh
        probability = 1.0 / (1.0 + np.exp(-k * (accel_diff - slip_thresh * 0.8)))
        self.slip_history.append(probability)
        return np.mean(self.slip_history)
    
    def detect_anomalies(self) -> List[str]:
        anomalies = []
        if self.slip_detected:
            anomalies.append("SLIP_DETECTED")
        if self._is_stationary() and abs(self.gyro_z) > self.drift_thresh:
            anomalies.append("IMU_DRIFT")
            self._imu_drift_detected = True
        else:
            self._imu_drift_detected = False
        if self.position_jump > self.jump_thresh:
            anomalies.append("ODOM_JUMP")
        if not self._imu_available:
            anomalies.append("IMU_UNAVAILABLE")
        return anomalies
    
    def get_state(self) -> EstimatorOutput:
        return EstimatorOutput(
            state=self.x[:8],
            covariance=self.P[:8, :8],
            covariance_norm=np.linalg.norm(self.P[:8, :8]),
            innovation_norm=self.last_innovation_norm,
            imu_bias=self.x[8:11].copy(),
            slip_probability=self.slip_probability,
            anomalies=self.detect_anomalies(),
            imu_available=self._imu_available,
            imu_drift_detected=self._imu_drift_detected
        )
    
    def reset(self) -> None:
        self.x = np.zeros(11)
        self.P = np.eye(11) * 0.1
        self.slip_detected = False
        self.slip_probability = 0.0
        self.last_innovation_norm = 0.0
        self.slip_history.clear()
        self.last_imu_time = None
        self.last_odom_time = None
        self.last_world_velocity = np.zeros(2)
        self.current_world_velocity = np.zeros(2)
        self.world_accel_vec = np.zeros(2)
        self._world_accel_initialized = False
        self.last_position = np.zeros(3)
        self.position_jump = 0.0
        self.gyro_z = 0.0
        self._imu_available = True
        self._imu_drift_detected = False
        self._last_odom_orientation = None
```
