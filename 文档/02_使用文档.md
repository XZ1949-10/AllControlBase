# Universal Controller 使用文档

> 版本: v3.17.12 | 日期: 2024-12-22

## 1. 快速开始

### 1.1 安装依赖

```bash
# 基础依赖
pip install numpy scipy PyYAML

# 可视化 Dashboard (可选)
pip install PyQt5 matplotlib

# ACADOS 求解器 (可选，提供更好的 MPC 性能)
# 请参考 ACADOS 官方文档安装
```

### 1.2 基本使用

```python
from universal_controller import ControllerManager, DEFAULT_CONFIG
from universal_controller.tests.fixtures import create_test_trajectory, create_test_odom

# 创建配置
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'differential'  # 差速车

# 创建控制器管理器
manager = ControllerManager(config)
manager.initialize_default_components()

# 控制循环
odom = create_test_odom(x=0, y=0, theta=0, vx=0.5)
trajectory = create_test_trajectory(trajectory_type='sine')

cmd = manager.update(odom, trajectory)
print(f"vx={cmd.vx:.2f}, omega={cmd.omega:.2f}")

# 清理
manager.shutdown()
```

### 1.3 运行示例

```bash
# 运行主程序示例
python -m universal_controller.main

# 运行可视化 Dashboard
python -m universal_controller.dashboard.run_dashboard

# 运行测试
python universal_controller/tests/run_all_tests.py
```

---

## 2. 平台配置

### 2.1 差速车 (Differential)

```python
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'differential'

# 输出: vx (前向速度), omega (角速度)
# 坐标系: base_link (机体坐标系)
```

### 2.2 阿克曼车 (Ackermann)

```python
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'ackermann'

# 输出: vx (前向速度), omega (角速度)
# 坐标系: base_link (机体坐标系)
# 特点: 有曲率约束
```

### 2.3 全向车 (Omni)

```python
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'omni'

# 输出: vx, vy (平面速度), omega (角速度)
# 坐标系: world (世界坐标系)
# 特点: 速度与航向解耦
```

### 2.4 四旋翼无人机 (Quadrotor)

```python
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'quadrotor'

# 输出: vx, vy, vz (3D 速度), omega (yaw rate)
# 坐标系: world (世界坐标系)
# 特点: 支持姿态控制接口
```

---

## 3. 输入数据格式

### 3.1 里程计 (Odometry)

```python
from universal_controller.core.data_types import Odometry, Header, Point3D

odom = Odometry(
    header=Header(stamp=time.time(), frame_id='odom'),
    pose_position=Point3D(x=1.0, y=2.0, z=0.0),
    pose_orientation=(qx, qy, qz, qw),  # 四元数
    twist_linear=(vx, vy, vz),          # 机体坐标系速度
    twist_angular=(wx, wy, wz)          # 角速度
)
```

**注意:**
- `pose` 是世界坐标系下的位姿
- `twist` 是机体坐标系下的速度
- EKF 内部会将 twist 转换到世界坐标系

### 3.2 轨迹 (Trajectory)

```python
from universal_controller.core.data_types import Trajectory, Point3D, Header
from universal_controller.core.enums import TrajectoryMode
import numpy as np

# Hard 轨迹 (仅位置点)
trajectory = Trajectory(
    header=Header(stamp=time.time(), frame_id='world'),
    points=[Point3D(x, y, z) for x, y, z in points_list],
    velocities=None,
    dt_sec=0.1,
    confidence=0.9,
    mode=TrajectoryMode.MODE_TRACK,
    soft_enabled=False
)

# Hard + Soft 轨迹 (位置点 + 速度建议)
trajectory = Trajectory(
    header=Header(stamp=time.time(), frame_id='world'),
    points=[Point3D(x, y, z) for x, y, z in points_list],
    velocities=np.array([[vx, vy, vz, wz] for _ in range(len(points_list))]),
    dt_sec=0.1,
    confidence=0.9,
    mode=TrajectoryMode.MODE_TRACK,
    soft_enabled=True
)
```

**轨迹模式:**
- `MODE_TRACK`: 正常跟踪
- `MODE_STOP`: 停车
- `MODE_HOVER`: 悬停 (无人机)
- `MODE_EMERGENCY`: 紧急停车

### 3.3 IMU (可选)

```python
from universal_controller.core.data_types import Imu, Header

imu = Imu(
    header=Header(stamp=time.time(), frame_id='imu_link'),
    orientation=(qx, qy, qz, qw),
    angular_velocity=(wx, wy, wz),
    linear_acceleration=(ax, ay, az)  # 包含重力
)
```

---

## 4. 输出数据格式

### 4.1 控制命令 (ControlOutput)

```python
cmd = manager.update(odom, trajectory)

# 访问控制命令
print(f"vx: {cmd.vx}")       # X 方向速度
print(f"vy: {cmd.vy}")       # Y 方向速度 (全向车/无人机)
print(f"vz: {cmd.vz}")       # Z 方向速度 (无人机)
print(f"omega: {cmd.omega}") # 角速度
print(f"frame_id: {cmd.frame_id}")  # 输出坐标系
print(f"success: {cmd.success}")    # 求解是否成功
print(f"solve_time_ms: {cmd.solve_time_ms}")  # 求解时间
```

### 4.2 诊断信息

```python
# 获取诊断信息
diagnostics = manager.get_diagnostics()

# 或通过回调获取
def on_diagnostics(diag):
    print(f"State: {diag['state']}")
    print(f"MPC Success: {diag['mpc_success']}")
    print(f"Alpha: {diag['consistency']['alpha_soft']}")

manager.set_diagnostics_callback(on_diagnostics)
```

### 4.3 控制器状态

```python
from universal_controller.core.enums import ControllerState

state = manager.get_state()

if state == ControllerState.NORMAL:
    print("正常运行")
elif state == ControllerState.BACKUP_ACTIVE:
    print("备用控制器激活")
elif state == ControllerState.STOPPING:
    print("正在停车")
```

---

## 5. 组件自定义

### 5.1 自定义状态估计器

```python
from universal_controller.core.interfaces import IStateEstimator
from universal_controller.core.data_types import EstimatorOutput, Odometry, Imu

class MyEstimator(IStateEstimator):
    def predict(self, dt: float) -> None:
        # 预测步骤
        pass
    
    def update_odom(self, odom: Odometry) -> None:
        # Odom 更新
        pass
    
    def update_imu(self, imu: Imu) -> None:
        # IMU 更新
        pass
    
    def get_state(self) -> EstimatorOutput:
        # 返回状态估计结果
        return EstimatorOutput(...)
    
    def reset(self) -> None:
        pass
    
    def set_imu_available(self, available: bool) -> None:
        pass
    
    def apply_drift_correction(self, dx, dy, dtheta) -> None:
        pass

# 使用自定义估计器
manager.initialize_components(state_estimator=MyEstimator())
```

### 5.2 自定义轨迹跟踪器

```python
from universal_controller.core.interfaces import ITrajectoryTracker
from universal_controller.core.data_types import Trajectory, ControlOutput, ConsistencyResult

class MyTracker(ITrajectoryTracker):
    def compute(self, state, trajectory, consistency) -> ControlOutput:
        # 计算控制命令
        return ControlOutput(vx=1.0, omega=0.0, frame_id='base_link')
    
    def get_health_metrics(self) -> dict:
        return {'type': 'my_tracker'}
    
    def set_horizon(self, horizon: int) -> bool:
        # 返回 True 表示成功，False 表示被节流
        return True
    
    def reset(self) -> None:
        pass
    
    def shutdown(self) -> None:
        pass

# 使用自定义跟踪器
manager.initialize_components(mpc_tracker=MyTracker())
```

### 5.3 组件注入

```python
from universal_controller.estimator.adaptive_ekf import AdaptiveEKFEstimator
from universal_controller.tracker.mpc_controller import MPCController
from universal_controller.tracker.pure_pursuit import PurePursuitController
from universal_controller.consistency.weighted_analyzer import WeightedConsistencyAnalyzer
from universal_controller.safety.safety_monitor import BasicSafetyMonitor
from universal_controller.transition.smooth_transition import ExponentialSmoothTransition
from universal_controller.transform.robust_transformer import RobustCoordinateTransformer
from universal_controller.health.mpc_health_monitor import MPCHealthMonitor

manager = ControllerManager(config)
manager.initialize_components(
    state_estimator=AdaptiveEKFEstimator(config),
    mpc_tracker=MPCController(config, platform_config),
    backup_tracker=PurePursuitController(config, platform_config),
    consistency_checker=WeightedConsistencyAnalyzer(config),
    safety_monitor=BasicSafetyMonitor(config, platform_config),
    smooth_transition=ExponentialSmoothTransition(config),
    coord_transformer=RobustCoordinateTransformer(config),
    mpc_health_monitor=MPCHealthMonitor(config)
)
```

---

## 6. ROS 集成

### 6.1 ROS 环境检测

```python
from universal_controller.core.ros_compat import ROS_AVAILABLE, TF2_AVAILABLE

print(f"ROS: {ROS_AVAILABLE}")
print(f"TF2: {TF2_AVAILABLE}")
```

### 6.2 ROS 节点示例

```python
#!/usr/bin/env python
import rospy
from nav_msgs.msg import Odometry as RosOdometry
from geometry_msgs.msg import Twist

from universal_controller import ControllerManager, DEFAULT_CONFIG
from universal_controller.core.data_types import Odometry, Trajectory, Header, Point3D

class ControllerNode:
    def __init__(self):
        rospy.init_node('universal_controller')
        
        config = DEFAULT_CONFIG.copy()
        config['system']['platform'] = rospy.get_param('~platform', 'differential')
        
        self.manager = ControllerManager(config)
        self.manager.initialize_default_components()
        
        self.odom_sub = rospy.Subscriber('/odom', RosOdometry, self.odom_callback)
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        
        self.last_odom = None
        self.trajectory = None
        
        rospy.Timer(rospy.Duration(0.02), self.control_loop)
    
    def odom_callback(self, msg):
        self.last_odom = Odometry(
            header=Header(stamp=msg.header.stamp.to_sec(), frame_id=msg.header.frame_id),
            pose_position=Point3D(msg.pose.pose.position.x, 
                                  msg.pose.pose.position.y, 
                                  msg.pose.pose.position.z),
            pose_orientation=(msg.pose.pose.orientation.x,
                             msg.pose.pose.orientation.y,
                             msg.pose.pose.orientation.z,
                             msg.pose.pose.orientation.w),
            twist_linear=(msg.twist.twist.linear.x,
                         msg.twist.twist.linear.y,
                         msg.twist.twist.linear.z),
            twist_angular=(msg.twist.twist.angular.x,
                          msg.twist.twist.angular.y,
                          msg.twist.twist.angular.z)
        )
    
    def control_loop(self, event):
        if self.last_odom is None or self.trajectory is None:
            return
        
        cmd = self.manager.update(self.last_odom, self.trajectory)
        
        twist = Twist()
        twist.linear.x = cmd.vx
        twist.linear.y = cmd.vy
        twist.angular.z = cmd.omega
        self.cmd_pub.publish(twist)

if __name__ == '__main__':
    node = ControllerNode()
    rospy.spin()
```

---

## 7. 无人机姿态控制

### 7.1 获取姿态命令

```python
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'quadrotor'

manager = ControllerManager(config)
manager.initialize_default_components()

# 获取速度命令
cmd = manager.update(odom, trajectory)

# 获取姿态命令 (仅无人机平台)
state = state_estimator.get_state().state
attitude_cmd = manager.compute_attitude_command(cmd, state, yaw_mode='velocity')

if attitude_cmd:
    print(f"Roll: {attitude_cmd.roll:.3f} rad")
    print(f"Pitch: {attitude_cmd.pitch:.3f} rad")
    print(f"Yaw: {attitude_cmd.yaw:.3f} rad")
    print(f"Thrust: {attitude_cmd.thrust:.3f}")
```

### 7.2 航向模式

```python
# 朝向运动方向
attitude_cmd = manager.compute_attitude_command(cmd, state, yaw_mode='velocity')

# 保持固定航向
attitude_cmd = manager.compute_attitude_command(cmd, state, yaw_mode='fixed')

# 外部指定航向
attitude_cmd = manager.compute_attitude_command(cmd, state, yaw_mode='manual')
```

### 7.3 悬停 yaw 设置

```python
# 设置悬停时的目标航向
manager.set_hover_yaw(target_yaw=1.57)  # 90 度
```

---

## 8. Dashboard 使用

### 8.1 启动 Dashboard

```bash
# 独立模式 (使用模拟数据)
python -m universal_controller.dashboard.run_dashboard

# 连接到 ControllerManager
python -c "
from universal_controller import ControllerManager, DEFAULT_CONFIG
from universal_controller.dashboard.main_window import run_dashboard

config = DEFAULT_CONFIG.copy()
manager = ControllerManager(config)
manager.initialize_default_components()

run_dashboard(controller_manager=manager, config=config)
"
```

### 8.2 Dashboard 面板说明

| 面板 | 显示内容 |
|------|----------|
| 系统信息 | ROS/ACADOS/TF2 状态、平台类型、控制频率 |
| 状态面板 | 当前状态、状态历史、状态持续时间 |
| MPC 健康 | 求解时间、KKT 残差、条件数、连续超时次数 |
| 降级状态 | 7 级状态指示灯 |
| 超时监控 | Odom/Traj/IMU 超时状态和延迟 |
| 一致性分析 | α 值、曲率一致性、速度方向一致性、时序平滑度 |
| 安全约束 | 速度/加速度限制状态 |
| 轨迹信息 | 轨迹点数、置信度、Soft 状态 |
| 轨迹可视化 | 2D/3D 轨迹显示、历史轨迹、速度向量 |
| 跟踪误差 | 横向误差、纵向误差、航向误差 |
| 控制输出 | vx, vy, vz, omega |
| 状态估计 | 位置、速度、航向、协方差、打滑概率 |
| 运行统计 | 运行时间、周期统计、MPC 成功率 |
| 警告日志 | 实时警告和错误信息 |

---

## 9. 配置调优

### 9.1 MPC 参数调优

```python
config['mpc'] = {
    'horizon': 20,           # 增大提高预测能力，但增加计算量
    'horizon_degraded': 10,  # 降级时的 horizon
    'dt': 0.02,              # 时间步长，与控制频率匹配
    'weights': {
        'position': 10.0,    # 位置跟踪权重
        'velocity': 1.0,     # 速度跟踪权重
        'heading': 5.0,      # 航向跟踪权重
        'control_accel': 0.1,  # 加速度控制权重 (惩罚加速度变化)
        'control_alpha': 0.1,  # 角加速度控制权重 (惩罚角加速度变化)
    },
}
```

### 9.2 一致性参数调优

```python
config['consistency'] = {
    'kappa_thresh': 0.5,           # 曲率一致性阈值，降低更严格
    'v_dir_thresh': 0.8,           # 速度方向一致性阈值
    'temporal_smooth_thresh': 0.5, # 时序平滑阈值
    'low_speed_thresh': 0.1,       # 低速阈值
    'alpha_min': 0.1,              # α 最小值，低于此值禁用 Soft
    'weights': {
        'kappa': 1.0,              # 曲率权重
        'velocity': 1.5,           # 速度方向权重
        'temporal': 0.8,           # 时序平滑权重
    },
}
```

### 9.3 安全参数调优

```python
config['safety'] = {
    'v_stop_thresh': 0.05,    # 停车速度阈值
    'vz_stop_thresh': 0.1,    # 垂直停车速度阈值
    'stopping_timeout': 5.0,  # 停车超时时间
    'emergency_decel': 3.0,   # 紧急减速度
    'velocity_margin': 1.1,   # 速度限制裕度
    'accel_margin': 1.5,      # 加速度限制裕度
    'state_machine': {
        'mpc_fail_thresh': 3,     # MPC 失败阈值
        'mpc_fail_decay': 0.5,    # MPC 成功时的衰减因子
    },
}

config['constraints'] = {
    'v_max': 2.0,       # 最大速度
    'omega_max': 2.0,   # 最大角速度
    'a_max': 1.5,       # 最大加速度
    'vz_max': 2.0,      # 最大垂直速度 (无人机)
}
```

### 9.4 EKF 参数调优

```python
config['ekf'] = {
    'use_odom_orientation_fallback': True,  # 航向备选
    'theta_covariance_fallback_thresh': 0.5,
    'adaptive': {
        'base_slip_thresh': 2.0,        # 打滑检测基础阈值
        'slip_velocity_factor': 0.5,    # 速度相关因子
        'slip_covariance_scale': 10.0,  # 打滑时协方差放大
        'stationary_covariance_scale': 0.1,  # 静止时协方差缩小
    },
    'measurement_noise': {
        'odom_position': 0.01,
        'odom_velocity': 0.1,
        'imu_accel': 0.5,
        'imu_gyro': 0.01,
    },
    'process_noise': {
        'position': 0.001,
        'velocity': 0.1,
        'orientation': 0.01,
        'angular_velocity': 0.1,
    },
}
```

---

## 10. 故障排除

### 10.1 常见问题

**Q: MPC 求解失败**
- 检查轨迹点数是否足够 (≥2)
- 检查 ACADOS 是否正确安装
- 查看 MPC 健康状态中的 KKT 残差和条件数

**Q: 控制器频繁切换到 BACKUP_ACTIVE**
- 检查 MPC 求解时间是否超过阈值
- 调整 `mpc.health_monitor.time_warning_thresh_ms`
- 减小 MPC horizon
- 检查 MPC 失败计数器衰减设置

**Q: Soft Head 被禁用**
- 检查一致性指标 (α 值)
- 检查轨迹置信度
- 调整一致性阈值

**Q: 超时导致停车**
- 检查 Odom/Trajectory 发布频率
- 调整超时阈值
- 检查网络延迟

**Q: 状态机频繁切换**
- 检查 MPC 失败计数器衰减设置
- 调整恢复阈值
- 检查安全监控器的加速度滤波参数

### 10.2 调试方法

```python
# 启用诊断回调
def debug_callback(diag):
    print(f"State: {diag['state']}")
    print(f"MPC: {diag['mpc_success']}, time={diag['mpc_solve_time_ms']:.1f}ms")
    print(f"Alpha: {diag['consistency']['alpha_soft']:.3f}")
    print(f"Timeout: odom={diag['timeout']['odom_timeout']}, traj={diag['timeout']['traj_timeout']}")

manager.set_diagnostics_callback(debug_callback)

# 获取详细诊断
diagnostics = manager.get_diagnostics()
print(diagnostics)

# 获取超时状态
timeout_status = manager.get_timeout_status()
print(f"Odom age: {timeout_status.last_odom_age_ms:.1f}ms")
print(f"Traj age: {timeout_status.last_traj_age_ms:.1f}ms")
```

### 10.3 日志级别

```python
import logging

# 设置日志级别
logging.basicConfig(level=logging.DEBUG)

# 或针对特定模块
logging.getLogger('universal_controller.estimator').setLevel(logging.DEBUG)
logging.getLogger('universal_controller.tracker').setLevel(logging.INFO)
```

---

## 11. API 参考

### 11.1 ControllerManager

```python
class ControllerManager:
    def __init__(self, config: Dict[str, Any])
    def initialize_default_components() -> None
    def initialize_components(**kwargs) -> None
    def update(odom, trajectory, imu=None) -> ControlOutput
    def get_state() -> ControllerState
    def get_diagnostics() -> Dict[str, Any]
    def get_timeout_status() -> TimeoutStatus
    def set_diagnostics_callback(callback) -> None
    def compute_attitude_command(cmd, state, yaw_mode) -> AttitudeCommand
    def set_hover_yaw(yaw: float) -> None
    def reset() -> None
    def shutdown() -> None
```

### 11.2 数据类型

```python
# 输入
Odometry(header, pose_position, pose_orientation, twist_linear, twist_angular)
Trajectory(header, points, velocities, dt_sec, confidence, mode, soft_enabled)
Imu(header, orientation, angular_velocity, linear_acceleration)

# 输出
ControlOutput(vx, vy, vz, omega, frame_id, success, solve_time_ms, health_metrics)
AttitudeCommand(roll, pitch, yaw, thrust)
EstimatorOutput(state, covariance, covariance_norm, innovation_norm, ...)
ConsistencyResult(alpha, kappa_consistency, v_dir_consistency, temporal_smooth, ...)
TimeoutStatus(odom_timeout, traj_timeout, traj_grace_exceeded, imu_timeout, ...)
```

### 11.3 枚举

```python
ControllerState: INIT, NORMAL, SOFT_DISABLED, MPC_DEGRADED, BACKUP_ACTIVE, STOPPING, STOPPED
PlatformType: ACKERMANN, DIFFERENTIAL, OMNI, QUADROTOR
TrajectoryMode: MODE_TRACK, MODE_STOP, MODE_HOVER, MODE_EMERGENCY
HeadingMode: FOLLOW_VELOCITY, FIXED, TARGET_POINT, MANUAL
TransformStatus: TF2_OK, FALLBACK_OK, FALLBACK_WARNING, FALLBACK_CRITICAL
```

---

## 12. 配置验证

### 12.1 验证配置参数

```python
from universal_controller.config import (
    validate_config, 
    ConfigValidationError,
    CONFIG_VALIDATION_RULES
)

config = DEFAULT_CONFIG.copy()
config['mpc']['horizon'] = -1  # 无效值

# 方式 1: 抛出异常
try:
    errors = validate_config(config, raise_on_error=True)
except ConfigValidationError as e:
    print(f"配置错误:\n{e}")

# 方式 2: 返回错误列表
errors = validate_config(config, raise_on_error=False)
for key, msg in errors:
    print(f"  {key}: {msg}")
```

### 12.2 逻辑一致性检查

```python
from universal_controller.config.validation import validate_logical_consistency

# 检查配置参数之间的逻辑关系
errors = validate_logical_consistency(config)

# 检查项:
# - min_lookahead < max_lookahead
# - horizon_degraded <= horizon
# - v_min <= v_max
# - thrust_min <= thrust_max
# - traj_grace_ms <= traj_timeout_ms
```

### 12.3 获取配置值

```python
from universal_controller.config.validation import get_config_value

# 支持点分隔的路径
horizon = get_config_value(config, 'mpc.horizon', default=20)
alpha_min = get_config_value(config, 'consistency.alpha_min', default=0.1)

# 支持备选配置
value = get_config_value(config, 'mpc.horizon', 
                         default=20, 
                         fallback_config=DEFAULT_CONFIG)
```

---

## 13. 速度平滑

### 13.1 使用 VelocitySmoother

```python
from universal_controller.core.velocity_smoother import VelocitySmoother

# 创建速度平滑器
smoother = VelocitySmoother(
    a_max=1.5,      # 最大水平加速度 (m/s²)
    az_max=1.0,     # 最大垂直加速度 (m/s²)
    alpha_max=3.0,  # 最大角加速度 (rad/s²)
    dt=0.02         # 时间步长 (s)
)

# 平滑控制命令
smoothed_cmd = smoother.smooth(new_cmd, last_cmd)

# 平滑停止
stop_cmd = smoother.smooth_to_stop(last_cmd, frame_id='base_link')

# 获取最大变化量
print(f"max_dv: {smoother.max_dv}")       # a_max * dt
print(f"max_dvz: {smoother.max_dvz}")     # az_max * dt
print(f"max_domega: {smoother.max_domega}") # alpha_max * dt
```

### 13.2 水平速度向量限制

VelocitySmoother 对水平速度使用向量限制，确保合成加速度不超过 a_max：

```python
# 内部实现逻辑
dvx = cmd.vx - last_cmd.vx
dvy = cmd.vy - last_cmd.vy
dv_magnitude = sqrt(dvx**2 + dvy**2)

if dv_magnitude > max_dv:
    scale = max_dv / dv_magnitude
    dvx *= scale
    dvy *= scale
```

---

## 14. 诊断发布

### 14.1 使用 DiagnosticsPublisher

```python
from universal_controller.diagnostics.publisher import DiagnosticsPublisher

# 创建诊断发布器
publisher = DiagnosticsPublisher(
    diagnostics_topic='/controller/diagnostics',
    cmd_topic='/cmd_unified'
)

# 添加回调 (线程安全)
def my_callback(diag_dict):
    print(f"State: {diag_dict['state']}")

publisher.add_callback(my_callback)

# 发布诊断
publisher.publish(
    current_time=time.monotonic(),
    state=ControllerState.NORMAL,
    cmd=control_output,
    state_output=estimator_output,
    consistency=consistency_result,
    mpc_health=mpc_health_status,
    timeout_status=timeout_status,
    transform_status={'fallback_duration_ms': 0},
    tracking_error={'lateral_error': 0.1},
    transition_progress=1.0,
    tf2_critical=False
)

# 获取最后发布的数据
last_diag = publisher.get_last_published()

# 移除回调
publisher.remove_callback(my_callback)
```

### 14.2 使用 DiagnosticsInput

```python
from universal_controller.core.diagnostics_input import DiagnosticsInput

# 创建诊断输入 (强类型)
diag_input = DiagnosticsInput(
    alpha=0.8,
    data_valid=True,
    mpc_success=True,
    odom_timeout=False,
    v_horizontal=1.0,
    current_state=ControllerState.NORMAL
)

# 转换为字典 (向后兼容)
diag_dict = diag_input.to_dict()

# 从字典创建
diag_input = DiagnosticsInput.from_dict(diag_dict)
```

---

## 15. 日志配置

### 15.1 使用统一日志接口

```python
from universal_controller.core.logging_config import get_logger, configure_logging
import logging

# 配置全局日志级别
configure_logging(level=logging.DEBUG)

# 获取模块日志器
logger = get_logger(__name__)
logger.info("信息消息")
logger.warning("警告消息")
logger.error("错误消息")
logger.debug("调试消息")
```

### 15.2 针对特定模块设置级别

```python
import logging

# 设置特定模块的日志级别
logging.getLogger('universal_controller.estimator').setLevel(logging.DEBUG)
logging.getLogger('universal_controller.tracker').setLevel(logging.INFO)
logging.getLogger('universal_controller.safety').setLevel(logging.WARNING)
```

---

## 16. 错误处理模式

### 16.1 配置错误处理

```python
from universal_controller.config import ConfigValidationError

try:
    manager = ControllerManager(config)
    manager.initialize_default_components()
except ConfigValidationError as e:
    print(f"配置错误: {e}")
    # 使用默认配置
    manager = ControllerManager(DEFAULT_CONFIG.copy())
    manager.initialize_default_components()
```

### 16.2 运行时错误处理

```python
try:
    cmd = manager.update(odom, trajectory, imu)
except Exception as e:
    logger.error(f"控制循环错误: {e}")
    # 发送零速度命令
    cmd = ControlOutput(vx=0, vy=0, vz=0, omega=0, 
                       frame_id='base_link', success=False)
```

### 16.3 状态恢复

```python
# 检测异常状态
state = manager.get_state()
if state == ControllerState.STOPPED:
    # 重置控制器
    manager.reset()
    
# 检测超时
timeout_status = manager.get_timeout_status()
if timeout_status.odom_timeout:
    logger.warning("里程计超时，等待数据恢复...")
```

---

## 17. 性能优化建议

### 17.1 MPC 性能优化

```python
# 减小 horizon 以降低计算量
config['mpc']['horizon'] = 15  # 默认 20

# 使用降级 horizon
config['mpc']['horizon_degraded'] = 8  # 默认 10

# 调整健康监控阈值
config['mpc']['health_monitor']['time_warning_thresh_ms'] = 10  # 默认 8
```

### 17.2 EKF 性能优化

```python
# 减少 IMU 更新频率 (如果 IMU 频率很高)
# 在 update_imu 调用前进行降采样

# 调整协方差更新
config['ekf']['covariance']['min_eigenvalue'] = 1e-5  # 默认 1e-6
```

### 17.3 诊断发布优化

```python
# 减少诊断发布频率
# 在回调中进行降采样
class DiagnosticsThrottler:
    def __init__(self, interval_ms=100):
        self.interval = interval_ms / 1000
        self.last_time = 0
    
    def should_publish(self):
        now = time.monotonic()
        if now - self.last_time >= self.interval:
            self.last_time = now
            return True
        return False
```
