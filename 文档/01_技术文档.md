# Universal Controller 技术文档

> 版本: v3.17.12 | 日期: 2024-12-22

## 1. 项目概述

Universal Controller 是一个基于 MPC (模型预测控制) 的通用轨迹跟踪控制器，支持多平台部署，包括地面车辆（差速车、阿克曼车、全向车）和无人机（四旋翼）。

### 1.1 核心特性

- **跨平台部署**: 统一状态空间支持地面车辆和无人机
- **Hard/Soft 融合**: 多维一致性门控，硬主干保证可用性，软建议提升平滑性
- **安全可靠**: 热备控制器 + 渐进式降级，异常时安全停车
- **高实时性**: ACADOS 求解器，15ms 内完成优化
- **插件化架构**: 核心模块可替换，便于扩展和维护
- **ROS 兼容**: 支持 ROS 环境和独立运行模式
- **完整 TF2 支持**: 多跳链式变换查找 (最多 10 跳)
- **单调时钟**: 全局使用 `time.monotonic()` 避免系统时间跳变影响

### 1.2 系统边界

**控制器负责:**
- 接收网络输出的轨迹和速度建议
- 状态估计与滤波
- 融合 Hard/Soft 输出，生成最优控制命令
- 处理延迟、异常、降级

**控制器不负责:**
- 视觉/感知处理
- 全局规划/建图
- 平台特定执行（由适配层处理）

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        ControllerManager                             │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────────┐  │
│  │ TimeoutMonitor│  │ StateMachine │  │ MPCHealthMonitor        │  │
│  └──────────────┘  └──────────────┘  └──────────────────────────┘  │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    AdaptiveEKFEstimator                       │  │
│  │  状态向量: [px, py, pz, vx, vy, vz, θ, ω, bias_ax, bias_ay, bias_az] │
│  └──────────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐                        │
│  │ WeightedConsistency│  │ RobustCoordTransformer│                  │
│  │    Analyzer       │  │  (TF2 + Fallback)     │                  │
│  └──────────────────┘  └──────────────────┘                        │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐  │
│  │  MPCController   │  │ PurePursuitController│ │ AttitudeController│ │
│  │  (主控制器)       │  │  (备用控制器)        │  │  (无人机姿态)     │  │
│  └──────────────────┘  └──────────────────┘  └──────────────────┘  │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐                        │
│  │ BasicSafetyMonitor│  │ SmoothTransition │                        │
│  └──────────────────┘  └──────────────────┘                        │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 数据流

```
输入:
  Odometry (/state/odom) ──┐
  Trajectory (/nn/local_traj) ──┼──> ControllerManager.update()
  IMU (/state/imu) ──────────┘
                                        │
                                        ▼
处理流程:
  1. TimeoutMonitor.check() ─────> 超时检测
  2. StateEstimator.predict() ───> EKF 预测 (使用实际时间间隔)
  3. StateEstimator.update_odom() ─> Odom 更新
  4. StateEstimator.update_imu() ──> IMU 更新
  5. ConsistencyChecker.compute() ─> 一致性分析
  6. CoordTransformer.transform() ─> 坐标变换
  7. MPCController.compute() ─────> MPC 求解
  8. MPCHealthMonitor.update() ───> 健康监控
  9. SafetyMonitor.check() ──────> 安全检查
  10. StateMachine.update() ──────> 状态转换
  11. SmoothTransition.blend() ───> 平滑过渡
                                        │
                                        ▼
输出:
  ControlOutput (/cmd_unified) ──> 控制命令
  DiagnosticsV2 (/controller/diagnostics) ──> 诊断信息
```

---

## 3. 核心模块详解

### 3.1 枚举定义 (`core/enums.py`)

#### 3.1.1 ControllerState - 控制器状态枚举

```python
class ControllerState(IntEnum):
    INIT = 0           # 初始化状态
    NORMAL = 1         # 正常运行
    SOFT_DISABLED = 2  # Soft Head 禁用
    MPC_DEGRADED = 3   # MPC 降级
    BACKUP_ACTIVE = 4  # 备用控制器激活
    STOPPING = 5       # 停车中
    STOPPED = 6        # 已停车
```

**状态转换逻辑:**
- `INIT → NORMAL`: 收到有效数据
- `NORMAL → SOFT_DISABLED`: α < 0.1 或数据无效
- `NORMAL → MPC_DEGRADED`: MPC 健康警告或 TF2 临界或安全检查失败
- `NORMAL → BACKUP_ACTIVE`: MPC 连续失败 ≥ 3 次
- `MPC_DEGRADED → BACKUP_ACTIVE`: MPC 求解失败
- `* → STOPPING`: Odom 超时或轨迹超时超过宽限期
- `STOPPING → STOPPED`: 速度 < 阈值或超时

#### 3.1.2 PlatformType - 平台类型枚举

```python
class PlatformType(IntEnum):
    ACKERMANN = 0     # 阿克曼转向车辆
    DIFFERENTIAL = 1  # 差速驱动车辆
    OMNI = 2          # 全向移动车辆
    QUADROTOR = 3     # 四旋翼无人机
```

#### 3.1.3 HeadingMode - 航向控制模式

```python
class HeadingMode(IntEnum):
    FOLLOW_VELOCITY = 0  # 朝向运动方向（默认）
    FIXED = 1            # 保持固定航向
    TARGET_POINT = 2     # 朝向目标点
    MANUAL = 3           # 外部指定航向
```

#### 3.1.4 TransformStatus - 坐标变换状态

```python
class TransformStatus(IntEnum):
    TF2_OK = 0              # TF2 正常
    FALLBACK_OK = 1         # 降级正常
    FALLBACK_WARNING = 2    # 降级警告 (>500ms)
    FALLBACK_CRITICAL = 3   # 降级临界 (>1000ms)
```

### 3.2 数据类型定义 (`core/data_types.py`)

#### 3.2.1 Trajectory - 轨迹数据类

```python
@dataclass
class Trajectory:
    header: Header                    # 消息头
    points: List[Point3D]             # Hard 轨迹点
    velocities: Optional[np.ndarray]  # Soft 速度 [N, 4]: [vx, vy, vz, wz]
    dt_sec: float                     # 时间步长
    confidence: float                 # 网络置信度 [0, 1]
    mode: TrajectoryMode              # 轨迹模式
    soft_enabled: bool                # Soft Head 是否启用
```

**关键方法:**
- `get_hard_velocities()`: 从 Hard 轨迹点计算隐含速度
- `get_velocities()`: 统一接口，优先返回 Soft 速度
- `has_valid_soft_velocities()`: 检查 Soft 速度是否有效
- `copy()`: 深拷贝轨迹对象

#### 3.2.2 ControlOutput - 控制器输出

```python
@dataclass
class ControlOutput:
    vx: float           # X 方向速度
    vy: float = 0.0     # Y 方向速度
    vz: float = 0.0     # Z 方向速度
    omega: float = 0.0  # 角速度
    frame_id: str       # 输出坐标系
    success: bool       # 求解是否成功
    solve_time_ms: float  # 求解时间
    health_metrics: Dict  # 健康指标
```

#### 3.2.3 EstimatorOutput - 状态估计器输出

```python
@dataclass
class EstimatorOutput:
    state: np.ndarray          # 状态向量 [8]
    covariance: np.ndarray     # 协方差矩阵 [8x8]
    covariance_norm: float     # 协方差范数
    innovation_norm: float     # 新息范数
    imu_bias: np.ndarray       # IMU 偏置 [3]
    slip_probability: float    # 打滑概率
    anomalies: List[str]       # 异常列表
    imu_available: bool        # IMU 是否可用
    imu_drift_detected: bool   # IMU 漂移检测
```

#### 3.2.4 ConsistencyResult - 一致性检查结果

```python
@dataclass
class ConsistencyResult:
    alpha: float                # 融合权重
    kappa_consistency: float    # 曲率一致性
    v_dir_consistency: float    # 速度方向一致性
    temporal_smooth: float      # 时序平滑度
    should_disable_soft: bool   # 是否禁用 Soft
    data_valid: bool            # 数据有效性
```

### 3.3 接口定义 (`core/interfaces.py`)

所有核心组件都实现了抽象接口，支持插件化替换：

| 接口 | 描述 | 默认实现 |
|------|------|----------|
| `IStateEstimator` | 状态估计器 | `AdaptiveEKFEstimator` |
| `ITrajectoryTracker` | 轨迹跟踪器 | `MPCController`, `PurePursuitController` |
| `IConsistencyChecker` | 一致性检查器 | `WeightedConsistencyAnalyzer` |
| `ISafetyMonitor` | 安全监控器 | `BasicSafetyMonitor` |
| `ISmoothTransition` | 平滑过渡 | `ExponentialSmoothTransition` |
| `ICoordinateTransformer` | 坐标变换器 | `RobustCoordinateTransformer` |
| `IAttitudeController` | 姿态控制器 | `QuadrotorAttitudeController` |

### 3.4 ROS 兼容层 (`core/ros_compat.py`)

支持两种运行模式：

**1. ROS 环境:**
- 使用真实的 `rospy`, `tf2_ros`, `tf.transformations`
- 自动发布诊断到 `/controller/diagnostics`
- 自动发布控制命令到 `/cmd_unified`

**2. 独立模式:**
- 使用 `mock/` 模块中的模拟实现
- 模拟 `rospy.Time`, `rospy.Duration`
- 模拟 TF2 Buffer 和变换查找

**关键函数:**
```python
# 四元数与欧拉角转换 (带数值稳定性保护)
euler_from_quaternion(q) -> (roll, pitch, yaw)
quaternion_from_euler(roll, pitch, yaw) -> (x, y, z, w)

# 时间工具
get_current_time() -> float
create_time(sec) -> Time
create_duration(sec) -> Duration
```

---

## 4. 状态估计器 (`estimator/adaptive_ekf.py`)

### 4.1 状态向量定义

```
x = [px, py, pz, vx, vy, vz, θ, ω, bias_ax, bias_ay, bias_az]
     ├─ 位置 ─┤  ├─ 速度 ─┤  ├航向┤├角速度┤├── IMU 偏置 ──┤
```

- 状态维度: 11 (输出时截取前 8 维)
- 协方差矩阵: 11×11

### 4.2 EKF 流程

```
1. predict(dt):
   - 先计算 Jacobian F (在预测前的状态点)
   - 运动学预测: x[0:3] += x[3:6] * dt
   - 航向更新: x[6] += x[7] * dt
   - 速度-航向耦合 (差速车/阿克曼车)
   - 协方差预测: P = F @ P @ F.T + Q * dt

2. update_odom(odom):
   - 保存 odom 方向作为航向备选
   - 机体速度转世界速度
   - 计算世界坐标系加速度
   - 自适应测量噪声调整
   - Kalman 更新 (Joseph 形式)

3. update_imu(imu):
   - 比力模型处理 (去除重力和偏置)
   - 打滑检测 (IMU 加速度 vs Odom 加速度)
   - 更新 IMU 偏置估计
   - Kalman 更新
```

### 4.3 自适应特性

**打滑检测:**
```python
slip_thresh = base_slip_thresh + slip_velocity_factor * current_velocity
slip_probability = sigmoid(accel_diff - slip_thresh * 0.8)
```

**测量噪声自适应:**
- 打滑时: `R_odom *= slip_covariance_scale` (10x)
- 静止时: `R_odom *= stationary_covariance_scale` (0.1x)
- 航向不确定时: 增加速度测量噪声

**航向备选:**
- 当 `P[6,6] > theta_covariance_fallback_thresh` 时
- 使用 Odom 方向代替 EKF 估计的航向

### 4.4 异常检测

```python
def detect_anomalies() -> List[str]:
    anomalies = []
    if slip_detected:
        anomalies.append("SLIP_DETECTED")
    if stationary and abs(gyro_z) > drift_thresh:
        anomalies.append("IMU_DRIFT")
    if position_jump > jump_thresh:
        anomalies.append("ODOM_JUMP")
    if not imu_available:
        anomalies.append("IMU_UNAVAILABLE")
    return anomalies
```

### 4.5 长时间暂停处理

ControllerManager 中实现了长时间暂停检测：
- 暂停 > 2s: 重置 EKF 避免累积误差
- 暂停 500ms-2s: 使用多步预测提高精度
- 时间间隔限制在 1ms-500ms 范围内

---

## 5. 轨迹跟踪控制器

### 5.1 MPC 控制器 (`tracker/mpc_controller.py`)

#### 5.1.1 ACADOS 求解器

**状态变量:** `[px, py, pz, vx, vy, vz, theta, omega]`
**控制输入:** `[ax, ay, az, alpha]` (加速度和角加速度)

**动力学模型:**
- 全向车/无人机: 直接速度积分
- 差速车/阿克曼车: 速度-航向耦合模型

**代价函数:**
```
J = Σ (x - x_ref)^T Q (x - x_ref) + u^T R u
```

**约束:**
- 速度约束: `|v| ≤ v_max`
- 角速度约束: `|ω| ≤ omega_max`
- 加速度约束: `|a| ≤ a_max`

#### 5.1.2 Fallback 求解器

当 ACADOS 不可用时，使用简化的 Pure Pursuit 风格求解：

```python
def _solve_fallback():
    # 1. 找最近点
    # 2. 计算前瞻点
    # 3. 计算曲率: κ = 2*y_local / L² (限制最大曲率 5.0)
    # 4. 目标点在后方时使用航向误差控制
    # 5. 加速度平滑
```

### 5.2 Pure Pursuit 控制器 (`tracker/pure_pursuit.py`)

备用控制器，用于 MPC 失败时的降级运行。

**前瞻距离计算:**
```python
lookahead = lookahead_dist + lookahead_ratio * current_v
lookahead = clip(lookahead, min_lookahead, max_lookahead)
```

**差速车输出:**
```python
# 转换到机体坐标系
local_x = dx * cos(θ) + dy * sin(θ)
local_y = -dx * sin(θ) + dy * cos(θ)

# 目标点在后方时使用航向误差控制
if local_x < 0:
    heading_error = atan2(sin(target_heading - theta), cos(target_heading - theta))
    omega = kp_heading * heading_error
    vx = 0 if abs(heading_error) > 60° else target_v * cos(heading_error)
else:
    # Pure Pursuit 曲率
    curvature = 2 * local_y / (local_x² + local_y²)
    omega = target_v * curvature
```

**全向车/无人机输出:**
```python
# 世界坐标系速度
vx = target_v * dx / dist
vy = target_v * dy / dist

# 航向控制
omega = kp_heading * heading_error
```

**角速度限制平滑过渡:**
```python
def _get_omega_limit(current_v):
    if current_v < v_low_thresh * 0.5:
        return omega_max_low
    elif current_v < v_low_thresh:
        ratio = (current_v - v_low_thresh * 0.5) / (v_low_thresh * 0.5)
        return omega_max_low + ratio * (omega_max - omega_max_low)
    return omega_max
```

### 5.3 姿态控制器 (`tracker/attitude_controller.py`)

用于四旋翼无人机，将速度命令转换为姿态命令。

**完整物理模型 (ZYX 欧拉角约定):**
```
m * a_world = R_body_to_world @ [0, 0, T]^T + [0, 0, -m*g]^T
```

**精确逆解过程:**
1. 计算总推力: `T/m = sqrt(ax² + ay² + (az+g)²)`
2. 转换到机体坐标系 (绕 z 轴旋转 -yaw)
3. 精确求解 roll: `sin(φ) = -ay_body / (T/m)`
4. 精确求解 pitch: `θ = -atan2(sin_pitch, cos_pitch)`
5. 应用姿态角速度限制

**悬停 yaw 漂移补偿 (F14.3):**
- 检测悬停状态 (水平和垂直速度都很小)
- 使用滞后逻辑避免频繁切换
- 记录悬停开始时的 yaw
- 累积漂移补偿

---

## 6. 一致性分析器 (`consistency/weighted_analyzer.py`)

### 6.1 一致性指标

| 指标 | 计算方法 | 阈值 |
|------|----------|------|
| 曲率一致性 | `1 - |κ_hard - κ_soft| / κ_thresh` | 0.5 |
| 速度方向一致性 | `cos(v_hard, v_soft)` 归一化 | 0.8 |
| 时序平滑度 | `1 - mean(|Δv|) / smooth_thresh` | 0.5 |

### 6.2 融合权重计算

使用加权几何平均，支持无效数据处理：

```python
# 计算有效权重
effective_w_kappa = w_kappa if kappa_valid else 0.0
effective_w_velocity = w_velocity if v_dir_valid else 0.0
effective_w_temporal = w_temporal if temporal_valid else 0.0
total_effective_weight = effective_w_kappa + effective_w_velocity + effective_w_temporal

# 加权几何平均
alpha = (
    effective_kappa ** effective_w_kappa *
    effective_v_dir ** effective_w_velocity *
    effective_temporal ** effective_w_temporal
) ** (1.0 / total_effective_weight) * confidence
```

默认权重: `w_kappa=1.0, w_velocity=1.5, w_temporal=0.8`

### 6.3 Soft 禁用条件

```python
should_disable_soft = (alpha < alpha_min)  # alpha_min = 0.1
```

---

## 7. 安全模块

### 7.1 安全监控器 (`safety/safety_monitor.py`)

**检查项:**
1. 水平速度限制: `v_horizontal ≤ v_max * velocity_margin`
2. 垂直速度限制 (无人机): `|vz| ≤ vz_max * velocity_margin`
3. 角速度限制: `|ω| ≤ omega_max * velocity_margin`
4. 水平加速度限制: `a_horizontal ≤ a_max * accel_margin`
5. 垂直加速度限制 (无人机): `|az| ≤ az_max * accel_margin`
6. 角加速度限制: `|α| ≤ alpha_max * accel_margin`

**加速度滤波:**
- 使用滑动窗口平均 (默认 3 帧)
- 低通滤波 (指数移动平均, α=0.3)
- 减少速度测量噪声导致的加速度估计噪声

**限制策略:**
- 超限时按比例缩放速度
- 超限时限制加速度变化

### 7.2 状态机 (`safety/state_machine.py`)

**MPC 失败计数器:**
- 使用浮点数支持衰减
- 失败时 +1，成功时 -0.5 (衰减)
- 达到阈值 (默认 3) 时切换到 BACKUP_ACTIVE

**状态转换条件:**

| 当前状态 | 条件 | 目标状态 |
|----------|------|----------|
| INIT | has_valid_data | NORMAL |
| NORMAL | safety_failed | MPC_DEGRADED |
| NORMAL | mpc_fail_count ≥ 3 | BACKUP_ACTIVE |
| NORMAL | alpha < 0.1 | SOFT_DISABLED |
| NORMAL | mpc_health.warning | MPC_DEGRADED |
| SOFT_DISABLED | alpha > 0.3 连续 5 次 | NORMAL |
| MPC_DEGRADED | mpc_health.can_recover 连续 5 次 | NORMAL/SOFT_DISABLED |
| BACKUP_ACTIVE | mpc_success | MPC_DEGRADED |
| * | odom_timeout 或 traj_grace_exceeded | STOPPING |
| STOPPING | v < v_stop_thresh | STOPPED |
| STOPPED | has_valid_data | NORMAL/MPC_DEGRADED |

### 7.3 超时监控器 (`safety/timeout_monitor.py`)

**超时阈值:**
| 数据源 | 超时阈值 | 宽限期 |
|--------|----------|--------|
| Odom | 500ms | - |
| Trajectory | 1000ms | 500ms |
| IMU | -1 (默认禁用) | - |
| 启动 | - | 5000ms |

**超时处理:**
- Odom 超时: 立即进入 STOPPING
- Trajectory 超时: 宽限期后进入 STOPPING
- IMU 超时: 禁用 IMU 更新，继续运行

**时间戳处理:**
- 使用单调时钟 `time.monotonic()` 计算超时
- 消息的 stamp 字段仅用于日志记录

---

## 8. 坐标变换器 (`transform/robust_transformer.py`)

### 8.1 TF2 集成

**查找流程:**
1. 直接查找 `(target, source)`
2. 反向查找 `(source, target)` 并求逆
3. BFS 多跳链式查找 (最多 10 跳)

**变换组合:**
```python
# SE(3) 组合: T_result = T1 * T2
# (R1, p1) * (R2, p2) = (R1*R2, R1*p2 + p1)
```

### 8.2 降级策略

**降级触发:** TF2 查找失败

**降级处理:**
1. 记录降级开始时间和位置
2. 使用 Odom 积分估计变换
3. 累积漂移估计

**降级状态:**
- `FALLBACK_OK`: < 500ms
- `FALLBACK_WARNING`: 500ms ~ 1000ms
- `FALLBACK_CRITICAL`: > 1000ms (触发 MPC_DEGRADED)

### 8.3 恢复校正

TF2 恢复时：
1. 计算 Odom 积分位移
2. 计算 TF2 实际位移
3. 漂移 = Odom 积分 - TF2 实际
4. 应用反向校正到状态估计器

**注意:** 如果没有真实 TF2 位置，不进行盲目校正，避免使情况更糟。

---

## 9. 健康监控 (`health/mpc_health_monitor.py`)

### 9.1 监控指标

| 指标 | 警告阈值 | 临界阈值 | 恢复阈值 |
|------|----------|----------|----------|
| 求解时间 | 8ms | 15ms | 6ms |
| 条件数 | 1e8 | - | 1e5 |
| KKT 残差 | 1e-3 | - | - |

### 9.2 预测性降级

```python
should_warn = (
    consecutive_near_timeout >= 3 or
    condition_number > 1e8 or
    kkt_residual > 1e-3
)
```

### 9.3 恢复条件

**主要恢复:**
```python
consecutive_good >= 5 and condition_number < 1e5
```

**备选恢复:**
```python
consecutive_good >= 10 and condition_number < 1e8
```

---

## 10. 平滑过渡 (`transition/smooth_transition.py`)

### 10.1 指数平滑

```python
alpha = 1 - exp(-elapsed / tau)
blended = from_cmd * (1 - alpha) + new_cmd * alpha
```

参数: `tau=0.1s, max_duration=0.5s, completion_threshold=0.95`

### 10.2 线性平滑

```python
alpha = min(elapsed / duration, 1.0)
blended = from_cmd * (1 - alpha) + new_cmd * alpha
```

参数: `duration=0.2s`

---

## 11. 控制器管理器 (`manager/controller_manager.py`)

### 11.1 主控制循环

```python
def update(odom, trajectory, imu=None) -> ControlOutput:
    # 0. 计算实际时间间隔 (使用单调时钟)
    actual_dt = current_time - last_update_time
    # 处理长时间暂停
    
    # 1. 超时监控
    timeout_status = timeout_monitor.check()
    
    # 2. 状态估计 (EKF: 预测 → Odom更新 → IMU更新)
    state_estimator.predict(actual_dt)  # 使用实际时间间隔
    state_estimator.update_odom(odom)
    state_estimator.update_imu(imu)
    state = state_estimator.get_state()
    
    # 3. 一致性检查
    consistency = consistency_checker.compute(trajectory)
    
    # 4. 坐标变换
    transformed_traj, tf_status = coord_transformer.transform_trajectory(...)
    
    # 5. MPC 计算
    mpc_cmd = mpc_tracker.compute(state, transformed_traj, consistency)
    
    # 6. 健康监控
    mpc_health = mpc_health_monitor.update(...)
    
    # 7. 选择控制器输出
    cmd = mpc_cmd if state in [NORMAL, SOFT_DISABLED, MPC_DEGRADED] else backup_cmd
    
    # 8. 安全检查 (在状态机更新之前)
    safety_decision = safety_monitor.check(state, cmd, diagnostics)
    
    # 9. 状态机更新 (只调用一次)
    new_state = state_machine.update(diagnostics)
    
    # 10. 平滑过渡
    cmd = smooth_transition.get_blended_output(cmd, current_time)
    
    # 11. 发布诊断
    _publish_diagnostics(...)
    
    return cmd
```

### 11.2 MPC Horizon 动态调整

- `NORMAL → MPC_DEGRADED`: horizon 从 20 降到 10
- `MPC_DEGRADED → NORMAL`: horizon 从 10 恢复到 20

### 11.3 诊断发布

支持两种模式：
1. **ROS 环境**: 发布到 `/controller/diagnostics` (JSON 格式)
2. **非 ROS 环境**: 通过回调函数获取

---

## 12. 配置参数 (`config/default_config.py`)

### 12.1 平台配置

| 平台 | 活跃维度 | 控制维度 | 约束 | 输出坐标系 |
|------|----------|----------|------|------------|
| ackermann | [0,1,3,6] | [3,7] | pz=0, vy=0, vz=0, curvature | base_link |
| differential | [0,1,3,6,7] | [3,7] | pz=0, vy=0, vz=0 | base_link |
| omni | [0,1,3,4,6,7] | [3,4,7] | pz=0, vz=0 | world |
| quadrotor | [0,1,2,3,4,5,6,7] | [3,4,5,7] | 无 | world |

### 12.2 主要配置参数

```python
DEFAULT_CONFIG = {
    'system': {
        'ctrl_freq': 50,        # 控制频率 (Hz)
        'platform': 'differential',
    },
    'mpc': {
        'horizon': 20,          # MPC 预测 horizon
        'horizon_degraded': 10, # 降级时的 horizon
        'dt': 0.02,             # 时间步长 (s)
        'weights': {
            'position': 10.0,
            'velocity': 1.0,
            'heading': 5.0,
            'control_accel': 0.1,   # 加速度控制权重
            'control_alpha': 0.1,   # 角加速度控制权重
        },
    },
    'watchdog': {
        'odom_timeout_ms': 500,       # <=0 禁用
        'traj_timeout_ms': 1000,      # <=0 禁用
        'traj_grace_ms': 500,
        'imu_timeout_ms': -1,         # <=0 禁用 (默认禁用，有 IMU 的平台需显式启用)
        'startup_grace_ms': 5000,
    },
    'consistency': {
        'kappa_thresh': 0.5,
        'v_dir_thresh': 0.8,
        'temporal_smooth_thresh': 0.5,
        'low_speed_thresh': 0.1,
        'alpha_min': 0.1,
        'weights': {'kappa': 1.0, 'velocity': 1.5, 'temporal': 0.8},
    },
    'safety': {
        'v_stop_thresh': 0.05,
        'vz_stop_thresh': 0.1,
        'stopping_timeout': 5.0,
        'emergency_decel': 3.0,
        'velocity_margin': 1.1,
        'accel_margin': 1.5,
        'state_machine': {
            'mpc_fail_thresh': 3,
            'mpc_fail_decay': 0.5,
        },
    },
    'constraints': {
        'v_max': 2.0,
        'v_min': 0.0,
        'omega_max': 2.0,
        'a_max': 1.5,
        'vz_max': 2.0,
    },
    'ekf': {
        'use_odom_orientation_fallback': True,
        'theta_covariance_fallback_thresh': 0.5,
        'adaptive': {
            'base_slip_thresh': 2.0,
            'slip_velocity_factor': 0.5,
            'slip_covariance_scale': 10.0,
        },
    },
    'attitude': {  # 无人机姿态控制
        'mass': 1.5,
        'gravity': 9.81,
        'roll_rate_max': 3.0,
        'pitch_rate_max': 3.0,
        'yaw_rate_max': 2.0,
        'roll_max': 0.5,
        'pitch_max': 0.5,
        'hover_yaw_compensation': True,
    },
}
```

---

## 13. Mock 模块 (`mock/`)

### 13.1 ROS Mock (`ros_mock.py`)

**MockRospy:**
- `Time`: 时间类，支持 `now()`, `from_sec()`, `to_sec()`
- `Duration`: 时长类
- 日志函数: `loginfo()`, `logwarn()`, `logerr()`

**MockTF2BufferCore:**
- 完整 SE(3) 变换实现
- 支持直接/反向/链式查找
- BFS 算法，最多 10 跳

### 13.2 数据 Mock (`data_mock.py`)

模拟 ROS 消息类型：
- `MockVector3`, `MockQuaternion`, `MockTransform`
- `MockHeader`, `MockTransformStamped`
- `MockOdometry`, `MockImu`

### 13.3 测试数据生成器 (`test_data_generator.py`)

```python
# 创建测试轨迹
trajectory = create_test_trajectory(
    num_points=20,
    dt=0.1,
    trajectory_type='sine',  # 'sine', 'circle', 'straight', 'figure8'
    soft_enabled=True
)

# 创建测试里程计
odom = create_test_odom(x=0, y=0, z=0, theta=0, vx=1.0, vy=0)

# 创建测试 IMU
imu = create_test_imu(
    orientation=(0, 0, 0, 1),
    angular_velocity=(0, 0, 0.1),
    linear_acceleration=(0, 0, 9.81)
)
```

---

## 14. Dashboard 可视化 (`dashboard/`)

### 14.1 面板组件

| 面板 | 功能 |
|------|------|
| SystemInfoPanel | 系统信息 (ROS/ACADOS/TF2 状态) |
| StatePanel | 控制器状态和状态历史 |
| MPCHealthPanel | MPC 健康状态 (求解时间、KKT残差) |
| DegradationPanel | 7 级降级状态指示 |
| TimeoutPanel | 超时监控 (Odom/Traj/IMU) |
| ConsistencyPanel | 一致性分析 (α、曲率、速度方向) |
| SafetyPanel | 安全约束状态 |
| TrajectoryPanel | 轨迹信息 |
| TrajectoryViewPanel | 轨迹可视化 (2D/3D) |
| TrackingPanel | 跟踪误差 |
| ControlPanel | 控制输出 |
| EstimatorPanel | 状态估计 (EKF) |
| StatisticsPanel | 运行统计 |
| AlertsPanel | 警告日志 |

### 14.2 数据源 (`data_source.py`)

```python
class DashboardDataSource:
    def get_display_data() -> DisplayData  # 获取统一显示数据
    def get_history() -> Dict              # 获取历史数据 (用于曲线图)
```

---

## 15. 诊断模块 (`diagnostics/`)

### 15.1 DiagnosticsPublisher 类

诊断发布器负责诊断数据的收集、格式化和发布，从 ControllerManager 中抽离，实现单一职责原则。

```python
class DiagnosticsPublisher:
    """诊断发布器"""
    
    def __init__(self, diagnostics_topic='/controller/diagnostics',
                 cmd_topic='/cmd_unified'):
        """
        初始化诊断发布器
        
        Args:
            diagnostics_topic: 诊断话题名称（用于日志和状态查询）
            cmd_topic: 控制命令话题名称（用于日志和状态查询）
        """
    
    def add_callback(self, callback: Callable[[Dict], None]) -> None:
        """添加诊断回调函数 (线程安全)"""
    
    def remove_callback(self, callback) -> None:
        """移除诊断回调函数"""
    
    def clear_callbacks(self) -> None:
        """清除所有回调函数"""
    
    def publish(self, current_time, state, cmd, state_output, 
                consistency, mpc_health, timeout_status, 
                transform_status, tracking_error, 
                transition_progress, tf2_critical) -> None:
        """构建诊断数据并通过回调发布"""
    
    def get_last_published(self) -> Optional[Dict]:
        """获取最后发布的诊断数据"""
```

**设计说明:**
- 本类不直接进行 ROS 发布，保持 universal_controller 的 ROS 无关性
- ROS 消息发布由 `controller_ros/io/publishers.py` 中的 `PublisherManager` 负责
- 通过回调机制将诊断数据传递给 ROS 层

**特性:**
- 线程安全的回调管理 (使用 `threading.Lock`)
- 自动移除连续失败超过 5 次的回调，防止日志泛滥
- 保持 universal_controller 的 ROS 无关性

### 15.2 DiagnosticsInput 类

强类型的诊断输入数据结构，替代 `Dict[str, Any]`，提高类型安全性。

```python
@dataclass
class DiagnosticsInput:
    """诊断输入数据类"""
    # 一致性相关
    alpha: float = 1.0
    data_valid: bool = True
    
    # MPC 相关
    mpc_health: Optional[MPCHealthStatus] = None
    mpc_success: bool = False
    
    # 超时相关
    odom_timeout: bool = False
    traj_timeout_exceeded: bool = False
    
    # 状态相关
    v_horizontal: float = 0.0
    vz: float = 0.0
    has_valid_data: bool = False
    
    # 变换相关
    tf2_critical: bool = False
    
    # 安全相关
    safety_failed: bool = False
    current_state: ControllerState = ControllerState.INIT
    
    def to_dict(self) -> dict:
        """转换为字典格式 (向后兼容)"""
    
    @classmethod
    def from_dict(cls, data: dict) -> 'DiagnosticsInput':
        """从字典创建实例 (向后兼容)"""
```

---

## 16. 速度平滑工具 (`core/velocity_smoother.py`)

### 16.1 VelocitySmoother 类

提供统一的速度平滑和限制功能，避免代码重复。

```python
class VelocitySmoother:
    """速度平滑器 - 限制控制命令的加速度"""
    
    def __init__(self, a_max: float, az_max: float, 
                 alpha_max: float, dt: float):
        """
        初始化速度平滑器
        
        Args:
            a_max: 最大水平加速度 (m/s²)
            az_max: 最大垂直加速度 (m/s²)
            alpha_max: 最大角加速度 (rad/s²)
            dt: 时间步长 (s)
        """
    
    @property
    def max_dv(self) -> float:
        """最大水平速度变化量: a_max * dt"""
    
    @property
    def max_dvz(self) -> float:
        """最大垂直速度变化量: az_max * dt"""
    
    @property
    def max_domega(self) -> float:
        """最大角速度变化量: alpha_max * dt"""
    
    def smooth(self, cmd: ControlOutput, 
               last_cmd: Optional[ControlOutput]) -> ControlOutput:
        """
        平滑控制命令
        
        对水平速度使用向量限制，确保合成加速度不超过 a_max。
        垂直速度和角速度独立限制。
        """
    
    def smooth_to_stop(self, last_cmd: Optional[ControlOutput], 
                       frame_id: str = "") -> ControlOutput:
        """平滑停止"""
```

**水平速度向量限制算法:**
```python
# 计算速度变化向量
dvx = cmd.vx - last_cmd.vx
dvy = cmd.vy - last_cmd.vy
dv_magnitude = sqrt(dvx**2 + dvy**2)

# 如果超过限制，按比例缩放
if dv_magnitude > max_dv:
    scale = max_dv / dv_magnitude
    dvx *= scale
    dvy *= scale

smoothed_vx = last_cmd.vx + dvx
smoothed_vy = last_cmd.vy + dvy
```

### 16.2 clip_velocity 函数

```python
def clip_velocity(vx, vy, last_vx, last_vy, max_dv) -> tuple:
    """
    限制水平速度变化 (独立限制，非向量)
    
    Returns:
        (clipped_vx, clipped_vy): 限制后的速度
    """
```

---

## 17. 配置验证系统 (`config/validation.py`)

### 17.1 验证函数

```python
def get_config_value(config: Dict, key_path: str, 
                     default=None, fallback_config=None) -> Any:
    """
    从配置字典中获取值，支持点分隔的路径
    
    Example:
        >>> config = {'mpc': {'horizon': 20}}
        >>> get_config_value(config, 'mpc.horizon')
        20
    """

def validate_config(config: Dict, validation_rules: Dict,
                    raise_on_error: bool = True) -> List[Tuple[str, str]]:
    """
    验证配置参数 (范围检查)
    
    Args:
        config: 配置字典
        validation_rules: 验证规则 {key_path: (min, max, description)}
        raise_on_error: 是否在发现错误时抛出异常
    
    Returns:
        错误列表 [(key_path, error_message), ...]
    """

def validate_logical_consistency(config: Dict) -> List[Tuple[str, str]]:
    """
    验证配置的逻辑一致性
    
    检查:
    - min_lookahead < max_lookahead
    - horizon_degraded <= horizon
    - v_min <= v_max
    - thrust_min <= thrust_max
    - traj_grace_ms <= traj_timeout_ms
    """

def validate_full_config(config: Dict, validation_rules: Dict,
                         raise_on_error: bool = True) -> List[Tuple[str, str]]:
    """完整配置验证 (范围检查 + 逻辑一致性)"""
```

### 17.2 验证规则示例

```python
# 每个配置模块定义自己的验证规则
MPC_VALIDATION_RULES = {
    'mpc.horizon': (1, 100, 'MPC 预测时域'),
    'mpc.dt': (0.001, 1.0, 'MPC 时间步长 (秒)'),
    'mpc.weights.position': (0.0, None, 'MPC 位置权重'),  # None 表示无上限
}

# 使用验证
from universal_controller.config import validate_config, ConfigValidationError

try:
    errors = validate_config(config, raise_on_error=True)
except ConfigValidationError as e:
    print(f"配置错误: {e}")
```

---

## 18. 日志配置 (`core/logging_config.py`)

### 18.1 统一日志接口

```python
def get_logger(name: str, level: Optional[int] = None) -> logging.Logger:
    """
    获取模块日志器
    
    Args:
        name: 日志器名称，通常使用 __name__
        level: 日志级别，默认为 INFO
    
    使用示例:
        from ..core.logging_config import get_logger
        logger = get_logger(__name__)
        logger.info("Message")
        logger.warning("Warning message")
    """

def configure_logging(level: int = logging.INFO, 
                     format_str: str = DEFAULT_FORMAT) -> None:
    """配置全局日志设置"""
```

### 18.2 预定义模块名称

```python
MODULE_NAMES = {
    'manager': 'universal_controller.manager',
    'estimator': 'universal_controller.estimator',
    'tracker': 'universal_controller.tracker',
    'safety': 'universal_controller.safety',
    'transform': 'universal_controller.transform',
    'consistency': 'universal_controller.consistency',
    'diagnostics': 'universal_controller.diagnostics',
    'health': 'universal_controller.health',
}
```

---

## 19. 测试模块 (`tests/`)

### 19.1 测试文件

| 文件 | 测试内容 |
|------|----------|
| `test_core.py` | 核心数据类型和枚举 |
| `test_components.py` | 各组件单元测试 |
| `test_ekf_estimator.py` | EKF 状态估计器测试 |
| `test_trackers.py` | MPC 和 Pure Pursuit 测试 |
| `test_attitude_controller.py` | 姿态控制器测试 |
| `test_tf2_transform.py` | TF2 变换测试 |
| `test_coordinate_transform.py` | 坐标变换测试 |
| `test_config_validation.py` | 配置验证测试 |
| `test_config_effects.py` | 配置效果测试 |
| `test_diagnostics_input.py` | 诊断输入测试 |
| `test_diagnostics_publisher.py` | 诊断发布器测试 |
| `test_integration.py` | 端到端集成测试 |
| `test_bug_fixes.py` | Bug 修复回归测试 |
| `test_system_usability.py` | 系统可用性测试 |

### 19.2 运行测试

```bash
# 运行所有测试
python universal_controller/tests/run_all_tests.py

# 运行单个测试文件
python -m pytest universal_controller/tests/test_core.py -v

# 运行特定测试类
python -m pytest universal_controller/tests/test_ekf_estimator.py::TestAdaptiveEKF -v

# 运行带覆盖率
python -m pytest universal_controller/tests/ --cov=universal_controller --cov-report=html
```

---

## 20. 版本历史

| 版本 | 主要变更 |
|------|----------|
| v3.17.12 | 单调时钟全局应用、加速度滤波、MPC失败计数器衰减、悬停检测滞后逻辑 |
| v3.17.11 | Bug 修复：四元数归一化、EKF Jacobian、MPC fallback 曲率计算 |
| v3.17.10 | Bug 修复：状态机计数器重置、姿态控制器除零保护 |
| v3.17.9 | 重构模拟数据模块，统一测试数据生成器 |
| v3.17.8 | 增强 TF2 链式查找 (BFS 算法，最多 10 跳) |
| v3.17.7 | 实现真实 TF2 集成，添加 ROS 兼容层 |
| v3.17.6 | 修复诊断发布类型错误 |
| v3.17.5 | 添加 DiagnosticsV2 dataclass |
| v3.17.4 | 添加组件注入方法 |
| v3.17 | 完善 ACADOS 集成，添加诊断发布功能 |
