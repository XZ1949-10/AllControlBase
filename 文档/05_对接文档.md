# Universal Controller 对接文档

> 版本: v1.1 | 日期: 2024-12-22 | 已验证

本文档描述如何将网络模型输出与 Universal Controller 进行对接。

---

## 1. 系统架构概览

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   感知/网络模型   │────▶│ Universal       │────▶│   机器人底盘     │
│                 │     │ Controller      │     │                 │
│ - 轨迹规划       │     │                 │     │ - 差速车         │
│ - 速度建议       │     │ - 状态估计       │     │ - 全向车         │
│                 │     │ - MPC 控制       │     │ - 无人机         │
└─────────────────┘     │ - 安全监控       │     └─────────────────┘
        │               └─────────────────┘              ▲
        │                       ▲                        │
        │                       │                        │
        ▼                       ▼                        │
┌─────────────────┐     ┌─────────────────┐              │
│   Trajectory    │     │   Odometry      │              │
│   (轨迹数据)     │     │   IMU           │              │
└─────────────────┘     │   (传感器数据)   │              │
                        └─────────────────┘              │
                                                         │
                        ┌─────────────────┐              │
                        │  ControlOutput  │──────────────┘
                        │  (控制命令)      │
                        └─────────────────┘
```

---

## 2. 数据结构定义

### 2.1 轨迹数据 (Trajectory)

这是网络模型需要输出的核心数据结构。

```python
from dataclasses import dataclass
from typing import List, Optional
import numpy as np

@dataclass
class Header:
    """消息头"""
    stamp: float        # 时间戳（秒），推理时刻的时间
    frame_id: str       # 坐标系名称，通常为 'base_link'
    seq: int = 0        # 序列号（可选）

@dataclass
class Point3D:
    """3D 点"""
    x: float            # X 坐标（米）
    y: float            # Y 坐标（米）
    z: float            # Z 坐标（米），地面车辆通常为 0

@dataclass
class Trajectory:
    """轨迹数据"""
    header: Header                          # 消息头
    points: List[Point3D]                   # Hard 轨迹点列表
    velocities: Optional[np.ndarray]        # Soft 速度数组 [N, 4]
    dt_sec: float                           # 轨迹点时间间隔（秒）
    confidence: float                       # 网络置信度 [0, 1]
    soft_enabled: bool                      # 是否启用 Soft Head
```

#### 字段详细说明

| 字段 | 类型 | 必需 | 取值范围 | 说明 |
|------|------|------|----------|------|
| `header.stamp` | float | ✅ | > 0 | 推理时刻的时间戳（秒），用于延迟补偿 |
| `header.frame_id` | str | ✅ | `'base_link'` | 坐标系，必须是机体坐标系 |
| `points` | List[Point3D] | ✅ | 长度 ≥ 2 | 轨迹点列表，局部坐标 |
| `velocities` | np.ndarray | ❌ | shape=[N, 4] | Soft 速度建议，仅 soft_enabled=True 时需要 |
| `dt_sec` | float | ✅ | 0.01 ~ 1.0 | 相邻轨迹点的时间间隔 |
| `confidence` | float | ✅ | 0.0 ~ 1.0 | 网络输出的置信度，影响 Soft 融合权重 |
| `soft_enabled` | bool | ✅ | True/False | 是否使用 Soft 速度建议 |

#### velocities 数组格式

```python
# velocities 是 [N, 4] 的 numpy 数组
# 每行表示一个轨迹点的速度建议
# ⚠️ 重要: velocities 长度应与 points 长度一致
velocities = np.array([
    [vx_0, vy_0, vz_0, wz_0],   # 第 0 个点的速度
    [vx_1, vy_1, vz_1, wz_1],   # 第 1 个点的速度
    [vx_2, vy_2, vz_2, wz_2],   # 第 2 个点的速度
    # ... 共 N 行，N = len(points)
])

# 其中:
# vx: X 方向速度 (m/s)，正值表示前进
# vy: Y 方向速度 (m/s)，正值表示左移（全向车/无人机）
# vz: Z 方向速度 (m/s)，正值表示上升（无人机）
# wz: 角速度 (rad/s)，正值表示逆时针旋转
```

#### mode 字段说明

```python
from universal_controller.core.enums import TrajectoryMode

# 轨迹模式（可选，默认 MODE_TRACK）
trajectory.mode = TrajectoryMode.MODE_TRACK  # 正常跟踪模式
# 其他模式: MODE_STOP (停车), MODE_HOLD (保持位置)
```

---

### 2.2 里程计数据 (Odometry)

控制器需要的传感器输入。

```python
@dataclass
class Odometry:
    """里程计数据"""
    header: Header
    pose_position: Point3D                              # 位置（odom 坐标系）
    pose_orientation: Tuple[float, float, float, float] # 四元数 (x, y, z, w)
    twist_linear: Tuple[float, float, float]            # 线速度 (vx, vy, vz) 机体坐标系
    twist_angular: Tuple[float, float, float]           # 角速度 (wx, wy, wz)
```

### 2.3 IMU 数据 (可选)

```python
@dataclass
class Imu:
    """IMU 数据"""
    header: Header
    orientation: Tuple[float, float, float, float]      # 四元数 (x, y, z, w)
    angular_velocity: Tuple[float, float, float]        # 角速度 (rad/s)
    linear_acceleration: Tuple[float, float, float]     # 线加速度 (m/s²)
```

### 2.4 控制输出 (ControlOutput)

控制器返回的控制命令。

```python
@dataclass
class ControlOutput:
    """控制命令"""
    vx: float                       # X 方向速度 (m/s)
    vy: float = 0.0                 # Y 方向速度 (m/s)，差速车为 0
    vz: float = 0.0                 # Z 方向速度 (m/s)，地面车辆为 0
    omega: float = 0.0              # 角速度 (rad/s)
    frame_id: str = ""              # 输出坐标系
    success: bool = True            # 求解是否成功
    solve_time_ms: float = 0.0      # MPC 求解耗时 (ms)
    health_metrics: Dict[str, Any]  # 健康指标 (kkt_residual, condition_number 等)
```

#### 健康指标说明

```python
# health_metrics 包含 MPC 求解器的健康信息
health_metrics = {
    'kkt_residual': 0.001,      # KKT 残差，越小越好
    'condition_number': 1.5,    # 条件数，越接近 1 越好
    'solver_status': 0,         # 求解器状态，0 表示成功
}
```

---

## 3. 坐标系说明

### 3.1 坐标系定义

```
base_link (机体坐标系)              odom (里程计坐标系)
┌───────────────────┐              ┌─────────────────────┐
│                   │              │                     │
│       ↑ X (前)    │              │    机器人轨迹       │
│       │           │   变换       │    ○──○──○──○       │
│   Y ←─┼─→         │  ──────▶    │         ↖           │
│  (左) │           │              │          当前位置   │
│       ↓           │              │                     │
│   机器人中心       │              │    启动位置 ●       │
└───────────────────┘              └─────────────────────┘
```

### 3.2 网络输出坐标系

**网络输出的轨迹必须在 `base_link` 坐标系下**：

- 原点：机器人当前位置
- X 轴：机器人前进方向
- Y 轴：机器人左侧方向
- Z 轴：向上

```python
# 示例：直线前进 2 米的轨迹
points = [
    Point3D(x=0.0, y=0.0, z=0.0),   # 当前位置（原点）
    Point3D(x=0.5, y=0.0, z=0.0),   # 前方 0.5m
    Point3D(x=1.0, y=0.0, z=0.0),   # 前方 1.0m
    Point3D(x=1.5, y=0.0, z=0.0),   # 前方 1.5m
    Point3D(x=2.0, y=0.0, z=0.0),   # 前方 2.0m
]
```

### 3.3 控制输出坐标系

控制输出的坐标系由平台配置 (`platform_config['output_frame']`) 决定：

| 平台类型 | 输出坐标系 | 说明 |
|----------|-----------|------|
| differential | base_link | vx=前进速度, vy=0, omega=角速度 |
| ackermann | base_link | vx=前进速度, vy=0, omega=角速度 |
| omni | odom | vx, vy=里程计坐标系速度, omega=角速度 |
| quadrotor | odom | vx, vy, vz=里程计坐标系速度, omega=yaw角速度 |

> 注意: `odom` 坐标系就是里程计坐标系，从机器人启动位置开始累积，不需要建图或定位。

---

## 4. 对接示例

### 4.1 基础对接（只有 Hard Head）

```python
import time
import numpy as np
from universal_controller.manager.controller_manager import ControllerManager
from universal_controller.config import DEFAULT_CONFIG
from universal_controller.core.data_types import (
    Trajectory, Header, Point3D, Odometry
)

# ============================================================
# 1. 初始化控制器
# ============================================================
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'differential'  # 差速车
config['constraints']['v_max'] = 1.5           # 最大速度 1.5 m/s
config['constraints']['omega_max'] = 1.0       # 最大角速度 1.0 rad/s

manager = ControllerManager(config)
manager.initialize_default_components()

# ============================================================
# 2. 网络推理函数（示例）
# ============================================================
def network_inference() -> Trajectory:
    """
    网络模型推理，输出轨迹
    
    这里用简单的直线轨迹作为示例，
    实际应用中替换为你的网络模型输出
    """
    # 生成直线轨迹：前进 2 米
    N = 20  # 轨迹点数
    dt = 0.1  # 时间间隔 100ms
    
    points = [
        Point3D(x=i * dt * 1.0, y=0.0, z=0.0)  # 速度 1.0 m/s
        for i in range(N)
    ]
    
    trajectory = Trajectory(
        header=Header(
            stamp=time.time(),      # 当前时间戳
            frame_id='base_link',   # 机体坐标系
        ),
        points=points,
        velocities=None,            # 无 Soft 速度
        dt_sec=dt,
        confidence=0.9,             # 置信度 90%
        soft_enabled=False,         # 不使用 Soft Head
    )
    
    return trajectory

# ============================================================
# 3. 获取传感器数据（示例）
# ============================================================
def get_odometry() -> Odometry:
    """
    获取里程计数据
    
    实际应用中从 ROS 话题或传感器接口获取
    """
    return Odometry(
        header=Header(stamp=time.time(), frame_id='odom'),
        pose_position=Point3D(x=0.0, y=0.0, z=0.0),
        pose_orientation=(0.0, 0.0, 0.0, 1.0),  # 四元数，无旋转
        twist_linear=(0.5, 0.0, 0.0),           # 当前速度 0.5 m/s
        twist_angular=(0.0, 0.0, 0.0),
    )

# ============================================================
# 4. 主控制循环
# ============================================================
def main():
    ctrl_freq = 50  # 控制频率 50 Hz
    dt = 1.0 / ctrl_freq
    
    print("控制器启动...")
    
    for i in range(500):  # 运行 10 秒
        # 获取传感器数据
        odom = get_odometry()
        
        # 获取网络输出的轨迹
        trajectory = network_inference()
        
        # 计算控制命令
        cmd = manager.update(odom, trajectory)
        
        # 输出控制命令
        if i % 50 == 0:  # 每秒打印一次
            print(f"[{i/ctrl_freq:.1f}s] vx={cmd.vx:.2f} m/s, "
                  f"omega={cmd.omega:.2f} rad/s, "
                  f"success={cmd.success}")
        
        # 发送到机器人底盘
        # send_to_robot(cmd.vx, cmd.omega)
        
        time.sleep(dt)
    
    manager.shutdown()
    print("控制器关闭")

if __name__ == '__main__':
    main()
```

### 4.2 完整对接（Hard + Soft Head）

```python
import time
import numpy as np
from universal_controller.manager.controller_manager import ControllerManager
from universal_controller.config import DEFAULT_CONFIG
from universal_controller.core.data_types import (
    Trajectory, Header, Point3D, Odometry, Imu
)

# ============================================================
# 1. 初始化控制器
# ============================================================
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'differential'

manager = ControllerManager(config)
manager.initialize_default_components()

# ============================================================
# 2. 网络推理函数（带 Soft Head）
# ============================================================
def network_inference_with_soft() -> Trajectory:
    """
    网络模型推理，输出轨迹和速度建议
    
    Hard Head: 输出轨迹点
    Soft Head: 输出速度建议
    """
    N = 20
    dt = 0.1
    
    # Hard Head 输出：轨迹点
    # 示例：左转弯轨迹
    radius = 2.0  # 转弯半径
    angular_speed = 0.5  # 角速度 rad/s
    
    points = []
    for i in range(N):
        t = i * dt
        angle = angular_speed * t
        x = radius * np.sin(angle)
        y = radius * (1 - np.cos(angle))
        points.append(Point3D(x=x, y=y, z=0.0))
    
    # Soft Head 输出：速度建议
    # [N, 4] 数组: [vx, vy, vz, wz]
    linear_speed = radius * angular_speed  # v = r * ω
    velocities = np.zeros((N, 4))
    for i in range(N):
        t = i * dt
        angle = angular_speed * t
        # 速度方向沿轨迹切线
        velocities[i, 0] = linear_speed * np.cos(angle)  # vx
        velocities[i, 1] = linear_speed * np.sin(angle)  # vy
        velocities[i, 2] = 0.0                            # vz
        velocities[i, 3] = angular_speed                  # wz
    
    trajectory = Trajectory(
        header=Header(
            stamp=time.time(),
            frame_id='base_link',
        ),
        points=points,
        velocities=velocities,      # ⭐ Soft 速度建议
        dt_sec=dt,
        confidence=0.85,            # 置信度影响 Soft 融合权重
        soft_enabled=True,          # ⭐ 启用 Soft Head
    )
    
    return trajectory

# ============================================================
# 3. 带 IMU 的控制循环
# ============================================================
def main_with_imu():
    ctrl_freq = 50
    dt = 1.0 / ctrl_freq
    
    for i in range(500):
        # 获取传感器数据
        odom = get_odometry()
        imu = Imu(
            header=Header(stamp=time.time(), frame_id='base_link'),
            orientation=(0.0, 0.0, 0.0, 1.0),
            angular_velocity=(0.0, 0.0, 0.1),       # 角速度
            linear_acceleration=(0.0, 0.0, 9.81),   # 加速度
        )
        
        # 获取网络输出
        trajectory = network_inference_with_soft()
        
        # 计算控制命令（带 IMU）
        cmd = manager.update(odom, trajectory, imu)
        
        # 发送到机器人
        # send_to_robot(cmd.vx, cmd.omega)
        
        time.sleep(dt)
    
    manager.shutdown()
```

### 4.3 全向车对接示例

```python
# 全向车配置
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'omni'

manager = ControllerManager(config)
manager.initialize_default_components()

def network_inference_omni() -> Trajectory:
    """全向车轨迹：可以横向移动"""
    N = 20
    dt = 0.1
    
    # 斜向移动轨迹
    points = [
        Point3D(x=i * dt * 0.5, y=i * dt * 0.3, z=0.0)
        for i in range(N)
    ]
    
    # 速度建议：vx 和 vy 都有值
    velocities = np.array([
        [0.5, 0.3, 0.0, 0.0]  # vx=0.5, vy=0.3
    ] * N)
    
    return Trajectory(
        header=Header(stamp=time.time(), frame_id='base_link'),
        points=points,
        velocities=velocities,
        dt_sec=dt,
        confidence=0.9,
        soft_enabled=True,
    )

# 控制输出
cmd = manager.update(odom, trajectory)
# cmd.vx = 世界坐标系 X 速度
# cmd.vy = 世界坐标系 Y 速度
# cmd.omega = 角速度
```

### 4.4 无人机对接示例

```python
# 无人机配置
config = DEFAULT_CONFIG.copy()
config['system']['platform'] = 'quadrotor'
config['attitude']['mass'] = 1.5  # 质量 1.5 kg

manager = ControllerManager(config)
manager.initialize_default_components()

def network_inference_quadrotor() -> Trajectory:
    """无人机 3D 轨迹"""
    N = 20
    dt = 0.1
    
    # 螺旋上升轨迹
    points = []
    for i in range(N):
        t = i * dt
        angle = 0.5 * t  # 角速度 0.5 rad/s
        radius = 1.0
        points.append(Point3D(
            x=radius * np.sin(angle),
            y=radius * (1 - np.cos(angle)),
            z=0.2 * t,  # 上升速度 0.2 m/s
        ))
    
    # 3D 速度建议
    velocities = np.zeros((N, 4))
    for i in range(N):
        t = i * dt
        angle = 0.5 * t
        velocities[i, 0] = 0.5 * np.cos(angle)  # vx
        velocities[i, 1] = 0.5 * np.sin(angle)  # vy
        velocities[i, 2] = 0.2                   # vz (上升)
        velocities[i, 3] = 0.5                   # wz (yaw 角速度)
    
    return Trajectory(
        header=Header(stamp=time.time(), frame_id='base_link'),
        points=points,
        velocities=velocities,
        dt_sec=dt,
        confidence=0.9,
        soft_enabled=True,
    )

# 控制输出
cmd = manager.update(odom, trajectory, imu)
# cmd.vx, cmd.vy, cmd.vz = 世界坐标系速度
# cmd.omega = yaw 角速度

# 获取姿态命令（无人机专用）
state = np.array([0, 0, 1, cmd.vx, cmd.vy, cmd.vz, 0, 0])
attitude_cmd = manager.compute_attitude_command(cmd, state)
# attitude_cmd.roll, attitude_cmd.pitch, attitude_cmd.thrust
```

---

## 5. 配置参数

### 5.1 必需配置

```python
config = {
    'system': {
        'ctrl_freq': 50,              # 控制频率 (Hz)
        'platform': 'differential',   # 平台类型
    },
    'constraints': {
        'v_max': 2.0,                 # 最大速度 (m/s)
        'omega_max': 2.0,             # 最大角速度 (rad/s)
        'a_max': 1.5,                 # 最大加速度 (m/s²)
    },
    'watchdog': {
        'odom_timeout_ms': 200,       # 里程计超时 (ms)
        'traj_timeout_ms': 200,       # 轨迹超时 (ms)
    },
}
```

### 5.2 平台类型选择

| 平台 | platform 值 | 说明 |
|------|-------------|------|
| 差速车 | `'differential'` | 两轮差速驱动，可原地转向 |
| 阿克曼车 | `'ackermann'` | 汽车式转向，不能原地转向 |
| 全向车 | `'omni'` | 麦克纳姆轮，可横向移动 |
| 四旋翼 | `'quadrotor'` | 无人机，3D 运动 |

### 5.3 轨迹相关配置

```python
config['trajectory'] = {
    'default_dt_sec': 0.1,            # 默认时间步长
    'default_confidence': 0.9,        # 默认置信度
    'default_frame_id': 'base_link',  # 默认坐标系
    'low_speed_thresh': 0.1,          # 低速阈值
}
```

---

## 6. 诊断与调试

### 6.1 获取诊断信息

```python
# 设置诊断回调
def on_diagnostics(diag):
    print(f"状态: {diag['state']}")
    print(f"MPC 成功: {diag['mpc_success']}")
    print(f"MPC 求解时间: {diag['mpc_solve_time_ms']:.2f} ms")
    print(f"一致性 α: {diag['consistency']['alpha_soft']:.2f}")
    print(f"跟踪误差: 横向={diag['tracking']['lateral_error']:.3f}m")

manager.set_diagnostics_callback(on_diagnostics)

# 或者直接获取
diag = manager.get_last_published_diagnostics()
```

### 6.2 一致性检查 (Soft Head 融合)

当使用 Soft Head 时，系统会自动计算一致性指标来决定 Soft 速度建议的融合权重：

```python
# 一致性指标
consistency = {
    'curvature': 0.95,      # 曲率一致性 (Hard vs Soft)
    'velocity_dir': 0.98,   # 速度方向一致性
    'temporal': 0.92,       # 时序平滑度
    'alpha_soft': 0.85,     # 最终融合权重 = 加权几何平均 × confidence
    'data_valid': True,     # 数据有效性
}

# alpha_soft 计算公式:
# alpha = (kappa^w1 × v_dir^w2 × temporal^w3)^(1/w_total) × confidence
# 其中 w1=1.0, w2=1.5, w3=0.8 (可配置)
```

### 6.3 状态机状态

| 状态 | 值 | 说明 |
|------|-----|------|
| INIT | 0 | 初始化，等待有效数据 |
| NORMAL | 1 | 正常运行，MPC 控制 |
| SOFT_DISABLED | 2 | Soft Head 禁用（一致性低） |
| MPC_DEGRADED | 3 | MPC 降级运行（horizon 减小） |
| BACKUP_ACTIVE | 4 | 备用控制器激活（Pure Pursuit） |
| STOPPING | 5 | 正在停车 |
| STOPPED | 6 | 已停车 |

### 6.4 MPC 健康监控

```python
# MPC 健康状态
mpc_health = {
    'kkt_residual': 0.001,              # KKT 残差
    'condition_number': 1.5,            # 条件数
    'consecutive_near_timeout': 0,      # 连续接近超时次数
    'degradation_warning': False,       # 降级警告
    'can_recover': True,                # 是否可恢复
}

# 当 MPC 健康状态恶化时，系统会自动:
# 1. 减小 horizon (20 → 10)
# 2. 切换到 MPC_DEGRADED 状态
# 3. 如果持续恶化，切换到 BACKUP_ACTIVE (Pure Pursuit)
```

### 6.5 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| 控制器不响应 | 轨迹点数 < 2 | 确保至少 2 个轨迹点 |
| 速度为 0 | 超时 | 检查时间戳是否正确 |
| 运动不平滑 | dt_sec 不匹配 | 确保 dt_sec 与实际间隔一致 |
| Soft 不生效 | soft_enabled=False | 设置 soft_enabled=True |
| Soft 权重低 | 一致性差 | 检查 Hard/Soft 轨迹是否一致 |
| 坐标系错误 | frame_id 错误 | 使用 'base_link' |
| MPC 求解失败 | 约束冲突 | 检查速度/加速度约束 |
| 状态估计漂移 | IMU 不可用 | 提供 IMU 数据 |

---

## 7. ROS 集成

### 7.1 ROS 话题订阅

```python
import rospy
from nav_msgs.msg import Odometry as RosOdometry
from sensor_msgs.msg import Imu as RosImu
from your_package.msg import TrajectoryMsg  # 自定义消息

class ROSInterface:
    def __init__(self):
        self.manager = ControllerManager(config)
        self.manager.initialize_default_components()
        
        # 订阅话题
        rospy.Subscriber('/odom', RosOdometry, self.odom_callback)
        rospy.Subscriber('/imu', RosImu, self.imu_callback)
        rospy.Subscriber('/nn/trajectory', TrajectoryMsg, self.traj_callback)
        
        # 发布话题
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        
        self.odom = None
        self.imu = None
        self.trajectory = None
    
    def odom_callback(self, msg):
        self.odom = self._convert_odom(msg)
    
    def traj_callback(self, msg):
        self.trajectory = self._convert_trajectory(msg)
    
    def control_loop(self):
        rate = rospy.Rate(50)
        while not rospy.is_shutdown():
            if self.odom and self.trajectory:
                cmd = self.manager.update(self.odom, self.trajectory, self.imu)
                self._publish_cmd(cmd)
            rate.sleep()
```

### 7.2 自定义轨迹消息

```
# TrajectoryMsg.msg
Header header
geometry_msgs/Point[] points
float64[] velocities  # 展平的 [N*4] 数组
float64 dt_sec
float64 confidence
bool soft_enabled
```

---

## 8. 性能要求

| 指标 | 要求 | 说明 |
|------|------|------|
| 控制频率 | ≥ 50 Hz | 推荐 50-100 Hz |
| 轨迹更新频率 | ≥ 10 Hz | 网络推理频率 |
| 轨迹点数 | 10-50 | 推荐 20 个点 |
| 轨迹时长 | 1-5 秒 | dt_sec * N |
| 延迟 | < 100 ms | 网络推理 + 通信延迟 |

---

## 9. 检查清单

在对接前，请确认以下事项：

### 轨迹数据
- [ ] 轨迹坐标系为 `base_link`（机体坐标系）
- [ ] 轨迹点数 ≥ 2
- [ ] `dt_sec` 与实际时间间隔一致
- [ ] `header.stamp` 为推理时刻的时间戳
- [ ] `confidence` 在 [0, 1] 范围内

### Soft Head（如果使用）
- [ ] `soft_enabled=True`
- [ ] `velocities` 不为 None
- [ ] `velocities` 形状为 `[N, 4]`，N = len(points)
- [ ] velocities 中的速度方向与轨迹点方向一致

### 传感器数据
- [ ] 里程计数据频率 ≥ 50 Hz
- [ ] 里程计时间戳正确
- [ ] IMU 数据（可选但推荐）

### 配置
- [ ] 平台类型配置正确
- [ ] 速度/加速度约束合理
- [ ] 超时参数适合你的系统

---

## 10. 联系与支持

如有问题，请参考：
- 技术文档：`文档/01_技术文档.md`
- 使用文档：`文档/02_使用文档.md`
- 测试示例：`universal_controller/tests/test_system_usability.py`
